From ab15d4b9c6976d6184e997760c0bc71b90af0da7 Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Thu, 7 Dec 2023 08:06:42 +0100
Subject: [PATCH] add RTL8261N support

Signed-off-by: John Crispin <john@phrozen.org>
---
 config                           |    9 +
 include/hsl/phy/hsl_phy.h        |   22 +
 include/hsl/phy/phy_common.h     | 1143 +++++++++++++++++++++
 include/hsl/phy/phy_rtl826xb.h   |  320 ++++++
 make/linux_opt.mk                |    4 +
 src/hsl/phy/Makefile             |    6 +
 src/hsl/phy/hsl_phy.c            |  185 +++-
 src/hsl/phy/phy_rtl826xb_patch.c | 1651 ++++++++++++++++++++++++++++++
 src/hsl/phy/rtl.c                |  520 ++++++++++
 src/hsl/phy/rtl826xb_phy.c       | 1521 +++++++++++++++++++++++++++
 src/init/ssdk_init.c             |   31 +
 11 files changed, 5410 insertions(+), 2 deletions(-)
 create mode 100644 include/hsl/phy/phy_common.h
 create mode 100644 include/hsl/phy/phy_rtl826xb.h
 create mode 100644 src/hsl/phy/phy_rtl826xb_patch.c
 create mode 100644 src/hsl/phy/rtl.c
 create mode 100644 src/hsl/phy/rtl826xb_phy.c

diff --git a/config b/config
index 7d924fbf..b649540e 100755
--- a/config
+++ b/config
@@ -269,6 +269,7 @@ endif
 #############################################
 ifeq (ALL_CHIP, $(CHIP_TYPE))
 	IN_AQUANTIA_PHY=TRUE
+	IN_RTL_PHY=TRUE
 	IN_QCA803X_PHY=TRUE
 	IN_QCA808X_PHY=TRUE
 	IN_PHY_I2C_MODE=TRUE
@@ -277,6 +278,7 @@ ifeq (ALL_CHIP, $(CHIP_TYPE))
 	IN_SFP=TRUE
 else ifeq (HPPE, $(CHIP_TYPE))
 	IN_AQUANTIA_PHY=TRUE
+	IN_RTL_PHY=TRUE
 	IN_QCA803X_PHY=TRUE
 	IN_QCA808X_PHY=TRUE
 	IN_PHY_I2C_MODE=TRUE
@@ -285,17 +287,21 @@ else ifeq (HPPE, $(CHIP_TYPE))
 	IN_MALIBU_PHY=TRUE
 else ifeq (CPPE, $(CHIP_TYPE))
 	IN_QCA808X_PHY=TRUE
+	IN_RTL_PHY=TRUE
 	IN_PHY_I2C_MODE=TRUE
 	IN_MALIBU_PHY=TRUE
 else ifeq (DESS, $(CHIP_TYPE))
 	IN_MALIBU_PHY=TRUE
+	IN_RTL_PHY=TRUE
 else ifeq (MP, $(CHIP_TYPE))
+	IN_RTL_PHY=TRUE
 	IN_QCA803X_PHY=TRUE
 	IN_QCA808X_PHY=TRUE
 	IN_SFP_PHY=TRUE
 	IN_SFP=TRUE
 else ifeq (APPE, $(CHIP_TYPE))
 	IN_AQUANTIA_PHY=TRUE
+	IN_RTL_PHY=TRUE
 	IN_QCA803X_PHY=TRUE
 	IN_QCA808X_PHY=TRUE
 	IN_SFP_PHY=TRUE
@@ -303,11 +309,13 @@ else ifeq (APPE, $(CHIP_TYPE))
 	IN_MALIBU_PHY=TRUE
 else ifeq (MPPE, $(CHIP_TYPE))
 	ifeq ($(LOWMEM_FLASH), enable)
+		IN_RTL_PHY=TRUE
 		IN_QCA803X_PHY=TRUE
 		ISISC_ENABLE=enable
 		MHT_ENABLE=disable
 	else
 		IN_AQUANTIA_PHY=TRUE
+		IN_RTL_PHY=TRUE
 		IN_QCA803X_PHY=TRUE
 		IN_QCA808X_PHY=TRUE
 		IN_SFP_PHY=TRUE
@@ -317,6 +325,7 @@ else
 	IN_QCA803X_PHY=FALSE
 	IN_QCA808X_PHY=FALSE
 	IN_AQUANTIA_PHY=FALSE
+	IN_RTL_PHY=FALSE
 	IN_MALIBU_PHY=FALSE
 	IN_SFP_PHY=FALSE
 	IN_SFP=FALSE
diff --git a/include/hsl/phy/hsl_phy.h b/include/hsl/phy/hsl_phy.h
index 6c71187c..ac4e035d 100755
--- a/include/hsl/phy/hsl_phy.h
+++ b/include/hsl/phy/hsl_phy.h
@@ -253,6 +253,10 @@ extern "C" {
 					      a_uint32_t phy_id,
 					      a_uint32_t source_id,
 					      led_ctrl_pattern_t * pattern);
+	typedef sw_error_t(*hsl_phy_pll_on) (a_uint32_t dev_id, a_uint32_t phy_id);
+	typedef sw_error_t(*hsl_phy_pll_off) (a_uint32_t dev_id, a_uint32_t phy_id);
+	typedef sw_error_t(*hsl_phy_ldo_set) (a_uint32_t dev_id, a_uint32_t phy_id,
+				a_bool_t enable);
 	typedef sw_error_t(*hsl_phy_ptp_security_set) (a_uint32_t dev_id,
 				a_uint32_t phy_id, fal_ptp_security_t *sec);
 
@@ -520,6 +524,9 @@ extern "C" {
 		hsl_phy_led_ctrl_pattern_set phy_led_ctrl_pattern_set;
 		hsl_phy_led_ctrl_pattern_get phy_led_ctrl_pattern_get;
 		hsl_phy_led_ctrl_source_set phy_led_ctrl_source_set;
+		hsl_phy_pll_on phy_pll_on;
+		hsl_phy_pll_off phy_pll_off;
+		hsl_phy_ldo_set phy_ldo_set;
 		hsl_phy_ptp_ops_t phy_ptp_ops;
 /*qca808x_start*/
 	} hsl_phy_ops_t;
@@ -542,6 +549,7 @@ typedef enum
 	QCA803X_PHY_CHIP,
 	SFP_PHY_CHIP,
 	MPGE_PHY_CHIP,
+	RTL_PHY_CHIP,
 /*qca808x_start*/
 	QCA808X_PHY_CHIP,
 	MAX_PHY_CHIP,
@@ -601,6 +609,7 @@ typedef struct {
 #define AQUANTIA_PHY_113C_B0    0x31c31C12
 #define AQUANTIA_PHY_113C_B1    0x31c31C13
 #define AQUANTIA_PHY_112C       0x03a1b792
+#define RTL_PHY                 0X001CCAF3
 
 #define PHY_805XV2              0x004DD082
 #define PHY_805XV1              0x004DD081
@@ -753,6 +762,12 @@ hsl_port_phy_led_ctrl_pattern_get(a_uint32_t dev_id, led_pattern_group_t group,
 sw_error_t
 hsl_port_phy_led_ctrl_source_set(a_uint32_t dev_id, a_uint32_t source_id,
 	led_ctrl_pattern_t *pattern);
+sw_error_t
+hsl_port_phy_pll_on(a_uint32_t dev_id, a_uint32_t port_id);
+sw_error_t
+hsl_port_phy_pll_off(a_uint32_t dev_id, a_uint32_t port_id);
+sw_error_t
+hsl_port_phy_ldo_set(a_uint32_t dev_id, a_uint32_t port_id, a_bool_t enable);
 phy_info_t *hsl_phy_info_get(a_uint32_t dev_id);
 
 sw_error_t
@@ -785,6 +800,9 @@ hsl_port_mode_to_phydev_interface(a_uint32_t dev_id, a_uint32_t port_mode);
 a_uint32_t
 hsl_port_mode_to_uniphy_mode(a_uint32_t dev_id, a_uint32_t port_mode);
 a_uint32_t
+hsl_uniphy_mode_to_port_mode(a_uint32_t dev_id, a_uint32_t port_id,
+	a_uint32_t uniphy_mode);
+a_uint32_t
 hsl_port_to_uniphy(a_uint32_t dev_id, a_uint32_t port_id);
 sw_error_t
 hsl_port_combo_phy_link_status_get(a_uint32_t dev_id,
@@ -811,6 +829,10 @@ hsl_port_phy_autoadv_set(a_uint32_t dev_id, a_uint32_t port_id,
 	a_uint32_t autoadv);
 sw_error_t
 hsl_port_phy_autoneg_restart(a_uint32_t dev_id, a_uint32_t port_id);
+sw_error_t
+hsl_port_phy_power_on(a_uint32_t dev_id, fal_port_t port_id);
+sw_error_t
+hsl_port_phy_power_off(a_uint32_t dev_id, fal_port_t port_id);
 /*qca808x_end*/
 a_uint32_t
 hsl_port_force_speed_get(a_uint32_t dev_id, a_uint32_t port_id);
diff --git a/include/hsl/phy/phy_common.h b/include/hsl/phy/phy_common.h
new file mode 100644
index 00000000..0b028355
--- /dev/null
+++ b/include/hsl/phy/phy_common.h
@@ -0,0 +1,1143 @@
+/*
+ * Copyright (C) 2009-2016 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * This program is the proprietary software of Realtek Semiconductor
+ * Corporation and/or its licensors, and only be used, duplicated,
+ * modified or distributed under the authorized license from Realtek.
+ *
+ * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
+ * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+ *
+ * $Revision$
+ * $Date$
+ *
+ * Purpose : PHY Common Driver APIs.
+ *
+ * Feature : PHY Common Driver APIs
+ *
+ */
+
+#ifndef __HAL_PHY_PHY_COMMON_H__
+#define __HAL_PHY_PHY_COMMON_H__
+
+
+#include <linux/kconfig.h>
+#include <linux/version.h>
+#include <linux/phy.h>
+#include <linux/kthread.h>
+
+#include "hsl.h"
+#include "ssdk_plat.h"
+#include "hsl_phy.h"
+
+/*
+ * Include Files
+ */
+/*
+ * Symbol Definition
+ */
+#define RTCT_ENABLE                 (0)
+#define RTCT_CH_A                   (4)
+#define RTCT_CH_B                   (5)
+#define RTCT_CH_C                   (6)
+#define RTCT_CH_D                   (7)
+#define RTCT_DONE                   (15)
+
+#define RTCT_BASE_ADDR              (0x802a)
+#define RTCT_LEN_ADDR_A             (RTCT_BASE_ADDR + 0x2)
+#define RTCT_LEN_ADDR_B             (RTCT_BASE_ADDR + 0x6)
+#define RTCT_LEN_ADDR_C             (RTCT_BASE_ADDR + 0xa)
+#define RTCT_LEN_ADDR_D             (RTCT_BASE_ADDR + 0xe)
+#define RTCT_STATUS_ADDR_A          (RTCT_BASE_ADDR + 0x0)
+#define RTCT_STATUS_ADDR_B          (RTCT_BASE_ADDR + 0x4)
+#define RTCT_STATUS_ADDR_C          (RTCT_BASE_ADDR + 0x8)
+#define RTCT_STATUS_ADDR_D          (RTCT_BASE_ADDR + 0xc)
+
+#define RTCT_STATUS_NORMAL          (5)
+#define RTCT_STATUS_SHORT           (4)
+#define RTCT_STATUS_OPEN            (3)
+#define RTCT_STATUS_MISSMATCH_SHORT (2)
+#define RTCT_STATUS_MISSMATCH_OPEN  (1)
+#define RTCT_STATUS_LINE_DRIVER     (0)
+
+#define GIGA_LITE_CTRL_REG          0xa42
+
+//#define PHY_C22_MMD_PAGE            0
+#define PHY_C22_MMD_PAGE            0x0A41
+#define PHY_C22_MMD_DEV_REG         13
+#define PHY_C22_MMD_ADD_REG         14
+
+/* MDIO Manageable Device(MDD) address*/
+#define PHY_MMD_PMAPMD              1
+#define PHY_MMD_PCS                 3
+#define PHY_MMD_AN                  7
+#define PHY_MMD_VEND1               30   /* Vendor specific 1 */
+#define PHY_MMD_VEND2               31   /* Vendor specific 2 */
+
+typedef enum rtk_phy_intr_e
+{
+    RTK_PHY_INTR_COMMON,                        /* Normal interrupt */
+    RTK_PHY_INTR_RLFD,                          /* Rapid Link Fault Detection interrupt for Fast Link Down Function */
+    RTK_PHY_INTR_TM_LOW,                        /* thermal meter over temperature interrupt for level low */
+    RTK_PHY_INTR_TM_HIGH,                       /* thermal meter over temperature interrupt for level High */
+    RTK_PHY_INTR_END
+} rtk_phy_intr_t;
+
+#if defined(IN_LINUX_STD_PTP)
+#include <linux/ptp_clock_kernel.h>
+enum {
+	PTP_PKT_SEQID_UNMATCHED,
+	PTP_PKT_SEQID_MATCHED,
+	PTP_PKT_SEQID_MATCH_MAX
+};
+
+enum {
+	MARS_PTP_MSG_SYNC,
+	MARS_PTP_MSG_DREQ,
+	MARS_PTP_MSG_PREQ,
+	MARS_PTP_MSG_PRESP,
+	MARS_PTP_MSG_MAX
+};
+
+typedef struct {
+	/* ptp filter class */
+	a_int32_t ptp_type;
+	/* ptp frame type */
+	a_int32_t pkt_type;
+} mars_ptp_cb;
+
+/* statistics for the event packet*/
+typedef struct {
+	/* the counter saves the packet with sequence id
+	 * matched and unmatched */
+	a_uint64_t sync_cnt[PTP_PKT_SEQID_MATCH_MAX];
+	a_uint64_t delay_req_cnt[PTP_PKT_SEQID_MATCH_MAX];
+	a_uint64_t pdelay_req_cnt[PTP_PKT_SEQID_MATCH_MAX];
+	a_uint64_t pdelay_resp_cnt[PTP_PKT_SEQID_MATCH_MAX];
+	a_uint64_t event_pkt_cnt;
+} ptp_packet_stat;
+
+typedef struct {
+	a_uint8_t reserved0;
+	a_uint8_t reserved1;
+	a_uint8_t msg_type;
+	a_uint16_t seqid;
+	a_uint32_t reserved2;
+	a_int64_t correction;
+} rtl_embeded_ts;
+
+struct rtl_ptp_info {
+	a_int32_t hwts_tx_type;
+	a_int32_t hwts_rx_type;
+	struct rtl_ptp_clock *clock;
+	struct delayed_work tx_ts_work;
+	struct delayed_work rx_ts_work;
+	/* work for writing ingress time to register */
+	struct delayed_work ingress_trig_work;
+	a_int32_t ingress_time;
+	struct sk_buff_head tx_queue;
+	struct sk_buff_head rx_queue;
+	rtl_embeded_ts embeded_ts;
+};
+#endif
+
+struct rtl_phy_info {
+	struct list_head list;
+	a_uint32_t dev_id;
+	/* phy real address,it is the mdio addr or the i2c slave addr */
+	a_uint32_t phy_addr;
+	/* the address of phy device, it is a fake addr for the i2c accessed phy */
+	a_uint32_t phydev_addr;
+#if defined(IN_LINUX_STD_PTP)
+	a_int32_t speed;
+	a_uint16_t clock_mode;
+	a_uint16_t step_mode;
+	/* work for gps sencond sync */
+	struct delayed_work ts_schedule_work;
+	a_bool_t gps_seconds_sync_en;
+	/*the statistics array records the counter of
+	 * rx and tx ptp event packet */
+	ptp_packet_stat pkt_stat[2];
+#endif
+};
+
+typedef struct {
+	struct phy_device *phydev;
+	struct rtl_phy_info *phy_info;
+#if defined(IN_LINUX_STD_PTP)
+	struct rtl_ptp_info ptp_info;
+#endif
+} rtl_priv;
+
+typedef enum rtk_enable_e
+{
+    DISABLED = 0,
+    ENABLED,
+    RTK_ENABLE_END
+} rtk_enable_t;
+
+typedef a_uint32_t                                  rtk_bitmap_t;
+
+typedef enum rtk_port_duplex_e
+{
+    PORT_HALF_DUPLEX = 0,
+    PORT_FULL_DUPLEX,
+    PORT_DUPLEX_END
+} rtk_port_duplex_t;
+
+typedef enum rtk_port_speed_e
+{
+    PORT_SPEED_10M = 0,
+    PORT_SPEED_100M,
+    PORT_SPEED_1000M,
+    PORT_SPEED_500M,
+    PORT_SPEED_2G,   /* Applicable to 8380 */
+    PORT_SPEED_2_5G,
+    PORT_SPEED_5G,
+    PORT_SPEED_10G,
+    PORT_SPEED_2_5G_LITE,
+    PORT_SPEED_5G_LITE,
+    PORT_SPEED_10G_LITE,
+    PORT_SPEED_END
+} rtk_port_speed_t;
+
+
+typedef enum rtk_port_masterSlave_e
+{
+    PORT_AUTO_MODE = 0,
+    PORT_SLAVE_MODE,
+    PORT_MASTER_MODE,
+    PORT_MASTER_SLAVE_END
+} rtk_port_masterSlave_t;
+
+typedef struct rtk_port_phy_ability_s
+{
+    a_uint32_t Half_10:1;
+    a_uint32_t Full_10:1;
+    a_uint32_t Half_100:1;
+    a_uint32_t Full_100:1;
+    a_uint32_t Half_1000:1;
+    a_uint32_t Full_1000:1;
+#if (defined(CONFIG_SDK_RTL8390) || defined(CONFIG_SDK_RTL9300))
+    a_uint32_t Half_10G:1;
+    a_uint32_t Full_10G:1;
+#endif
+    a_uint32_t adv_2_5G:1;
+    a_uint32_t adv_5G:1;
+    a_uint32_t adv_10GBase_T:1;
+    a_uint32_t FC:1;
+    a_uint32_t AsyFC:1;
+} rtk_port_phy_ability_t;
+
+typedef enum rtk_port_linkStatus_e
+{
+    PORT_LINKDOWN = 0,
+    PORT_LINKUP,
+    PORT_LINKSTATUS_END
+} rtk_port_linkStatus_t;
+
+
+/* value for RTK_PHY_CTRL_INTR_MASK*/
+#define RTK_PHY_CTRL_INTR_MASK_COMMON          (1 << RTK_PHY_INTR_COMMON)
+#define RTK_PHY_CTRL_INTR_MASK_RLFD            (1 << RTK_PHY_INTR_RLFD)
+#define RTK_PHY_CTRL_INTR_MASK_TM_LOW          (1 << RTK_PHY_INTR_TM_LOW)
+#define RTK_PHY_CTRL_INTR_MASK_TM_HIGH         (1 << RTK_PHY_INTR_TM_HIGH)
+
+/* bitmap width in bits */
+#define BITMAP_WIDTH                            (sizeof(rtk_bitmap_t) * 8)
+#define RTK_MAX_PORT_PER_UNIT                       64   
+
+#define BITMAP_ARRAY_CNT(_num_of_indexes)       ((_num_of_indexes + (BITMAP_WIDTH - 1)) / BITMAP_WIDTH)
+
+#define RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST    BITMAP_ARRAY_CNT(RTK_MAX_PORT_PER_UNIT)
+
+typedef struct rtk_portmask_s
+{
+    rtk_bitmap_t    bits[RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST];
+} rtk_portmask_t;
+
+typedef enum rt_port_ethType_id_e
+{
+    HWP_FE_ID = 0,
+    HWP_GE_ID,
+    HWP_2_5GE_ID,
+    HWP_5GE_ID,
+    HWP_XGE_ID,
+    HWP_SXGE_ID,
+    HWP_ETHTYPE_ID_END,
+}rt_port_ethType_id_t;
+
+/* port ethernet type */
+typedef enum rt_port_ethType_e
+{
+    HWP_FE             = (0x1 << HWP_FE_ID),          /* Fast ethernet port */
+    HWP_GE             = (0x1 << HWP_GE_ID),          /* Giga ethernet port */
+    HWP_2_5GE          = (0x1 << HWP_2_5GE_ID),       /* 2.5 Giga ethernet port */
+    HWP_5GE            = (0x1 << HWP_5GE_ID),         /* 5 Giga ethernet port */
+    HWP_XGE            = (0x1 << HWP_XGE_ID),         /* 10 Giga ethernet port */
+    HWP_SXGE           = (0x1 << HWP_SXGE_ID),        /* Cascade Stack port */
+    HWP_ETHTYPE_END    = (0x1 << HWP_ETHTYPE_ID_END), /* Ether type end*/
+}rt_port_ethType_t;
+
+
+/* PHY SerDes eye-monitor handler */
+typedef a_uint32_t (*phy_sds_eyeMon_hdlr_t)(a_uint32_t xAxis, a_uint32_t yAxis, a_uint32_t frameNum, void *pDb, a_uint32_t val);
+
+
+/* Function Name:
+ *      phy_common_unavail
+ * Description:
+ *      Return chip not support
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_PORT_NOT_SUPPORTED   - functions not supported by this port
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_unavail(void);
+
+/* Function Name:
+ *      phy_common_AutoNegoEnable_get
+ * Description:
+ *      Get auto-negotiation enable status of the specific port
+ * Input:
+ *      unit - unit id
+ *      port - port id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_autoNegoEnable_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *pEnable);
+
+
+/* Function Name:
+ *      phy_common_autoNegoEnable_set
+ * Description:
+ *      Set auto-negotiation enable status of the specific port
+ * Input:
+ *      unit - unit id
+ *      port - port id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_autoNegoEnable_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      phy_common_duplex_get
+ * Description:
+ *      Get duplex mode status of the specific port
+ * Input:
+ *      unit - unit id
+ *      port - port id
+ * Output:
+ *      pDuplex - pointer to PHY duplex mode status
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_duplex_get(a_uint32_t unit, a_uint32_t port, a_uint32_t *pDuplex);
+
+/* Function Name:
+ *      phy_common_duplex_get
+ * Description:
+ *      Set duplex mode status of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      duplex        - duplex mode of the port, full or half
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_duplex_set(a_uint32_t unit, a_uint32_t port, a_uint32_t duplex);
+
+/* Function Name:
+ *      phy_common_enable_set
+ * Description:
+ *      Set PHY interface status of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      enable        - admin configuration of PHY interface
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_enable_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+/* Function Name:
+ *      phy_common_enable_get
+ * Description:
+ *      Get PHY interface status of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      enable        - admin configuration of PHY interface
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+a_uint32_t
+phy_common_enable_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *enable);
+
+/* Function Name:
+ *      phy_common_speed_get
+ * Description:
+ *      Get PHY negotiated speed of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      pSpeed        - PHY negotiated speed
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_speed_get(a_uint32_t unit, a_uint32_t port, a_uint32_t *pSpeed);
+
+/* Function Name:
+ *      phy_common_speedStatusResReg_get
+ * Description:
+ *      Get PHY operational link speed status from proprietary register
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pSpeed - pointer to PHY operational link speed
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      Only PHY that supports proprietary resolution register can use this driver!
+ */
+extern a_uint32_t
+phy_common_speedStatusResReg_get(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t *pSpeed);
+
+/* Function Name:
+ *      phy_common_speedDuplexStatusResReg_get
+ * Description:
+ *      Get PHY operational link speed-duplex status from proprietary register
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pSpeed - pointer to PHY operational link speed
+ *      pDuplex - pointer to PHY operational link duplex
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      Only PHY that supports proprietary resolution register can use this driver!
+ */
+extern a_uint32_t
+phy_common_speedDuplexStatusResReg_get(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex);
+
+/* Function Name:
+ *      phy_common_reg_get
+ * Description:
+ *      Get PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      page    - PHY page
+ *      phy_reg - PHY register
+ * Output:
+ *      pData   - pointer buffer of read data
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_get(a_uint32_t unit,  a_uint32_t port, a_uint32_t page, a_uint32_t phy_reg, a_uint32_t *pData);
+
+/* Function Name:
+ *      phy_common_reg_set
+ * Description:
+ *      Set PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      page    - PHY page
+ *      phy_reg - PHY register
+ *      data    - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_set(a_uint32_t unit, a_uint32_t port, a_uint32_t page, a_uint32_t phy_reg, a_uint32_t data);
+
+/* Function Name:
+ *      phy_common_reg_park_get
+ * Description:
+ *      Get PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      page    - PHY page
+ *      parkPage    - PHY park page
+ *      phy_reg - PHY register
+ * Output:
+ *      pData   - pointer buffer of read data
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_park_get(a_uint32_t unit, a_uint32_t port, a_uint32_t page, a_uint32_t parkPage, a_uint32_t phy_reg, a_uint32_t *pData);
+
+
+/* Function Name:
+ *      phy_common_reg_park_set
+ * Description:
+ *      Set PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      page    - PHY page
+ *      parkPage    - PHY park page
+ *      phy_reg - PHY register
+ *      data    - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_park_set(a_uint32_t unit, a_uint32_t port, a_uint32_t page, a_uint32_t parkPage, a_uint32_t phy_reg, a_uint32_t data);
+
+
+/* Function Name:
+ *      phy_common_reg_mmd_portmask_set
+ * Description:
+ *      Set PHY registers in those portmask.
+ * Input:
+ *      unit     - unit id
+ *      portmask - portmask
+ *      mmdAddr  - mmd device address
+ *      mmdReg   - mmd reg id
+ *      data     - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. portmask valid range is bit 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_mmd_portmask_set(
+    a_uint32_t          unit,
+    rtk_portmask_t  portmask,
+    a_uint32_t          mmdAddr,
+    a_uint32_t          mmdReg,
+    a_uint32_t          data);
+
+
+/* Function Name:
+ *      phy_common_reg_extParkPage_get
+ * Description:
+ *      Get PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      mainPage    - main page id
+ *      extPage     - extension page id
+ *      parkPage    - parking page id
+ *      phy_reg - PHY register
+ * Output:
+ *      pData   - pointer buffer of read data
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_extParkPage_get(
+    a_uint32_t      unit,
+    a_uint32_t  port,
+    a_uint32_t      mainPage,
+    a_uint32_t      extPage,
+    a_uint32_t      parkPage,
+    a_uint32_t      phy_reg,
+    a_uint32_t      *pData);
+
+
+/* Function Name:
+ *      phy_common_reg_extParkPage_set
+ * Description:
+ *      Set PHY registers.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      mainPage    - main page id
+ *      extPage     - extension page id
+ *      parkPage    - parking page id
+ *      phy_reg - PHY register
+ *      data    - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. port valid range is 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_extParkPage_set(
+    a_uint32_t      unit,
+    a_uint32_t  port,
+    a_uint32_t      mainPage,
+    a_uint32_t      extPage,
+    a_uint32_t      parkPage,
+    a_uint32_t      phy_reg,
+    a_uint32_t      data);
+
+/* Function Name:
+ *      phy_common_extParkPage_portmask_set
+ * Description:
+ *      Set PHY registers in those portmask.
+ * Input:
+ *      unit     - unit id
+ *      portmask - portmask
+ *      mainPage    - main page id
+ *      extPage     - extension page id
+ *      parkPage    - parking page id
+ *      phy_reg  - PHY register
+ *      data     - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      1. portmask valid range is bit 0 ~ 27
+ *      2. page valid range is 0 ~ 31
+ *      3. phy_reg valid range is 0 ~ 31
+ */
+extern a_uint32_t
+phy_common_reg_extParkPage_portmask_set(
+    a_uint32_t          unit,
+    rtk_portmask_t  portmask,
+    a_uint32_t          mainPage,
+    a_uint32_t          extPage,
+    a_uint32_t          parkPage,
+    a_uint32_t          phy_reg,
+    a_uint32_t          data);
+	
+
+a_uint32_t rtl_phy_driver_register(void);
+
+/* Function Name:
+ *      phy_common_masterSlave_get
+ * Description:
+ *      Get PHY configuration of master/slave mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ * Output:
+ *      pMasterSlaveCfg     - pointer to the PHY master slave configuration
+ *      pMasterSlaveActual  - pointer to the PHY master slave actual link status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID       - invalid port id
+ *      RT_ERR_NULL_POINTER  - input parameter may be null pointer
+ * Note:
+ *      This function only works on giga/ 10g port to get its master/slave mode configuration.
+ */
+extern a_uint32_t
+phy_common_masterSlave_get(a_uint32_t unit, a_uint32_t port, rtk_port_masterSlave_t *pMasterSlaveCfg, rtk_port_masterSlave_t *pMasterSlaveActual);
+
+/* Function Name:
+ *      phy_common_masterSlave_set
+ * Description:
+ *      Set PHY configuration of master/slave mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ *      masterSlave         - PHY master slave configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID       - invalid port id
+ *      RT_ERR_INPUT         - invalid input parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_masterSlave_set(a_uint32_t unit, a_uint32_t port, rtk_port_masterSlave_t masterSlave);
+
+
+/* Function Name:
+ *      phy_common_masterSlaveMmd_get
+ * Description:
+ *      Get PHY configuration of master/slave mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ * Output:
+ *      pMasterSlaveCfg     - pointer to the PHY master slave configuration
+ *      pMasterSlaveActual  - pointer to the PHY master slave actual link status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID       - invalid port id
+ *      RT_ERR_NULL_POINTER  - input parameter may be null pointer
+ * Note:
+ *      This function only works on giga/ 10g port to get its master/slave mode configuration.
+ */
+extern a_uint32_t
+phy_common_masterSlaveMmd_get(
+    a_uint32_t              unit,
+    a_uint32_t          port,
+    rtk_port_masterSlave_t   *pMasterSlaveCfg,
+    rtk_port_masterSlave_t   *pMasterSlaveActual);
+
+/* Function Name:
+ *      phy_common_reset_set
+ * Description:
+ *      Set PHY standard register Reset bit (0.15).
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_reset_set(a_uint32_t unit, a_uint32_t port);
+
+
+
+/* Function Name:
+ *      phy_common_loopback_get
+ * Description:
+ *      Get PHY Loopback mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ *      pEnable           -loopback mode status;
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_loopback_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      phy_common_loopback_set
+ * Description:
+ *      Set PHY Loopback mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ *      enable              - ENABLED: Enable loopback;
+ *                            DISABLED: Disable loopback. PHY back to normal operation.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_loopback_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      phy_field_read
+ * Description:
+ *      Read PHY register field configuration
+ * Input:
+ *      unit - unit id
+ *      port - port id
+ *      page - page number
+ *      reg  - register
+ *      endBit    - end bit of configure field
+ *      startBit  - start bit of configure field
+ * Output:
+ *      data - PHY register field Configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ * Note:
+ *      None
+ */
+a_uint32_t
+phy_field_read(a_uint32_t unit, a_uint32_t port, a_uint32_t page, a_uint32_t reg,
+    a_uint32_t endBit, a_uint32_t startBit, a_uint32_t *data);
+
+/* Function Name:
+ *      phy_field_write
+ * Description:
+ *      Write PHY register field configuration
+ * Input:
+ *      unit - unit id
+ *      port - port id
+ *      page - page number
+ *      reg  - register
+ *      endBit    - end bit of configure field
+ *      startBit  - start bit of configure field
+ *      data - PHY register field Configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ * Note:
+ *      None
+ */
+a_uint32_t
+phy_field_write(a_uint32_t unit, a_uint32_t port, a_uint32_t page, a_uint32_t reg,
+    a_uint32_t endBit, a_uint32_t startBit, a_uint32_t data);
+
+/* Function Name:
+ *      phy_common_eyeMonPixel_get
+ * Description:
+ *      PHY SerDes eye-monitor utility to set val to the database according to x,y,z
+ * Input:
+ *      xAxis - x position
+ *      yAxis - y position
+ *      frameNum - frame number
+ * Output:
+ *      pDb - 3 dimension a_uint32_t array database. E.g. a_uint32_t a[RTK_EYE_MON_FRAME_MAX][RTK_EYE_MON_X_MAX][RTK_EYE_MON_Y_MAX]
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_eyeMonPixel_get(a_uint32_t xAxis, a_uint32_t yAxis, a_uint32_t frameNum, void *pDb, a_uint32_t val);
+
+
+/* Function Name:
+ *      phy_common_c45_enable_set
+ * Description:
+ *      Set PHY interface status of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      enable        - admin configuration of PHY interface
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_enable_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      phy_common_c45_enable_get
+ * Description:
+ *      Get PHY interface state enable/disable of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ * Output:
+ *      pEnable       - pointer to admin configuration of PHY interface
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_enable_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+*      phy_common_c45_linkStatus_get
+* Description:
+*      Get PHY link status from standard register (1.2).
+* Input:
+*      unit    - unit id
+*      port    - port id
+* Output:
+*      pStatus - pointer to the link status
+* Return:
+*      RT_ERR_OK
+*      RT_ERR_FAILED
+* Note:
+*      The Link Status bit (Status Register 1.2) has LL (Latching Low) attribute
+*      for link failure. Please refer IEEE 802.3 for detailed.
+*/
+extern a_uint32_t
+phy_common_c45_linkStatus_get(a_uint32_t unit, a_uint32_t port, rtk_port_linkStatus_t *pStatus);
+
+/* Function Name:
+ *      phy_common_c45_loopback_get
+ * Description:
+ *      Get PHY Loopback mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ *      pEnable           -loopback mode status;
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_loopback_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      phy_common_c45_loopback_set
+ * Description:
+ *      Set PHY Loopback mode of the specific port
+ * Input:
+ *      unit                - unit id
+ *      port                - port id
+ *      enable              - ENABLED: Enable loopback;
+ *                            DISABLED: Disable loopback. PHY back to normal operation.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_loopback_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+
+
+/* Function Name:
+ *      phy_common_c45_eeeEnable_get
+ * Description:
+ *      Get enable status of EEE function in the specified port.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pEnable - pointer to enable status of EEE
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_PORT_ID      - invalid port id
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_eeeEnable_get(a_uint32_t unit, a_uint32_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      phy_common_c45_eeeEnable_set
+ * Description:
+ *      Set enable status of EEE function in the specified port.
+ * Input:
+ *      unit   - unit id
+ *      port   - port id
+ *      enable - enable status of EEE
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT - The module is not initial
+ *      RT_ERR_UNIT_ID  - invalid unit id
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_c45_eeeEnable_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable);
+
+
+/* Function Name:
+ *      phy_common_c45_speedDuplexStatus_get
+ * Description:
+ *      Get PHY operational link speed-duplex status.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pSpeed - pointer to PHY operational link speed
+ *      pDuplex - pointer to PHY operational link duplex
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      none
+ */
+extern a_uint32_t
+phy_common_c45_speedDuplexStatus_get(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex);
+
+/* Function Name:
+ *      phy_common_c45_speedStatusResReg_get
+ * Description:
+ *      Get PHY operational link speed status from proprietary register
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pSpeed - pointer to PHY operational link speed
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      Only PHY that supports proprietary resolution register can use this driver!
+ */
+extern a_uint32_t
+phy_common_c45_speedStatusResReg_get(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t *pSpeed);
+
+
+/* Function Name:
+ *      phy_common_c45_speedDuplexStatusResReg_get
+ * Description:
+ *      Get operational link speed-duplex status from proprietary register
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ * Output:
+ *      pSpeed - pointer to PHY operational link speed
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      Only PHY that supports proprietary resolution register can use this driver!
+ */
+extern a_uint32_t
+phy_common_c45_speedDuplexStatusResReg_get(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex);
+
+/* Function Name:
+ *      phy_common_autoNegoAbility_get
+ * Description:
+ *      Get ability advertisement for auto negotiation of the specific port
+ * Input:
+ *      unit        - unit id
+ *      port        - port id
+ * Output:
+ *      pAbility    - pointer to PHY auto negotiation ability
+ * Return:
+ *      RT_ERR_OK       - OK
+ *      RT_ERR_FAILED   - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_autoNegoAbility_get(a_uint32_t unit, a_uint32_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      phy_common_autoNegoAbility_set
+ * Description:
+ *      Set ability advertisement for auto negotiation of the specific port
+ * Input:
+ *      unit        - unit id
+ *      port        - port id
+ *      pAbility    - auto negotiation ability that is going to set to PHY
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - OK
+ *      RT_ERR_FAILED   - invalid parameter
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_autoNegoAbility_set(a_uint32_t unit, a_uint32_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      phy_common_speed_set
+ * Description:
+ *      Set speed mode status of the specific port
+ * Input:
+ *      unit          - unit id
+ *      port          - port id
+ *      speed         - link speed status 10/100/1000
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - OK
+ *      RT_ERR_FAILED             - invalid parameter
+ *      RT_ERR_CHIP_NOT_SUPPORTED - copper media chip is not supported Force-1000
+ * Note:
+ *      None
+ */
+extern a_uint32_t
+phy_common_speed_set(a_uint32_t unit, a_uint32_t port, rtk_port_speed_t speed);
+
+extern sw_error_t phy_826xb_duplex_set(a_uint32_t unit, a_uint32_t port, fal_port_duplex_t duplex);
+extern sw_error_t phy_826xb_speed_set(a_uint32_t unit, a_uint32_t port, fal_port_speed_t speed);
+#endif /* __HAL_PHY_PHY_COMMON_H__ */
diff --git a/include/hsl/phy/phy_rtl826xb.h b/include/hsl/phy/phy_rtl826xb.h
new file mode 100644
index 00000000..b5893ae5
--- /dev/null
+++ b/include/hsl/phy/phy_rtl826xb.h
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2021 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * This program is the proprietary software of Realtek Semiconductor
+ * Corporation and/or its licensors, and only be used, duplicated,
+ * modified or distributed under the authorized license from Realtek.
+ *
+ * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
+ * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+ *
+ * $Revision:  $
+ * $Date:  $
+ *
+ * Purpose : PHY 826XB/8261N Driver APIs.
+ *
+ * Feature : PHY 826XB/8261N Driver APIs.
+ *
+ */
+#ifndef __HAL_PHY_PHY_RTL826XB_H__
+#define __HAL_PHY_PHY_RTL826XB_H__
+
+/*
+ * Include Files
+ */
+#include "phy_common.h"
+
+/*
+ * Symbol Definition
+ */
+//#define PHY_826X_CONSTRUCT_BROADCAST  1
+
+typedef unsigned char uint8;
+typedef signed char int8;
+typedef int uint16;
+typedef int int16;
+typedef unsigned int uint32;
+typedef signed int int32;
+
+
+#define RTLBIT_0       0x0001
+#define RTLBIT_1       0x0002
+#define RTLBIT_2       0x0004
+#define RTLBIT_3       0x0008
+#define RTLBIT_4       0x0010
+#define RTLBIT_5       0x0020
+#define RTLBIT_6       0x0040
+#define RTLBIT_7       0x0080
+#define RTLBIT_8       0x0100
+#define RTLBIT_9       0x0200
+#define RTLBIT_10      0x0400
+#define RTLBIT_11      0x0800
+#define RTLBIT_12      0x1000
+#define RTLBIT_13      0x2000
+#define RTLBIT_14      0x4000
+#define RTLBIT_15      0x8000
+
+
+
+
+#define REG32_FIELD_SET(_data, _val, _fOffset, _fMask)      ((_data & ~(_fMask)) | ((_val << (_fOffset)) & (_fMask)))
+#define REG32_FIELD_GET(_data, _fOffset, _fMask)            ((_data & (_fMask)) >> (_fOffset))
+
+#define RTL826XB_MII_ADDR_C45  (1<<30)
+#define RTL826XB_REG_ADDRESS(dev_ad, reg_num) (RTL826XB_MII_ADDR_C45 |\
+			((dev_ad & 0x1f) << 16) | (reg_num & 0xFFFF))
+			
+  /* Speed, bits 9:7 */
+#define RTL_STATUS_SPEED_MASK               0xc000
+
+#define RTK_MAX_NUM_OF_UNIT                         16     
+#define RTK_MAX_PORT_PER_UNIT                       64     
+
+
+typedef enum rtk_phy_ctrl_e {
+    RTK_PHY_CTRL_AN_COMPLETE,                    /* status of auto-negotiation complete, R */
+    RTK_PHY_CTRL_LED_1_MODE,                     /* LED mode for LED1, RW */
+    RTK_PHY_CTRL_LED_2_MODE,                     /* LED mode for LED2, RW */
+    RTK_PHY_CTRL_LED_3_MODE,                     /* LED mode for LED3, RW */
+    RTK_PHY_CTRL_LED_4_MODE,                     /* LED mode for LED4, RW */
+    RTK_PHY_CTRL_LED_5_MODE,                     /* LED mode for LED5, RW */
+    RTK_PHY_CTRL_LED_6_MODE,                     /* LED mode for LED6, RW */
+    RTK_PHY_CTRL_LED_CFG_FLASH_RATE,             /* LED flash rate, RW */
+    RTK_PHY_CTRL_LED_CFG_BLINK_RATE,             /* LED blink rate, RW */
+    RTK_PHY_CTRL_LED_1_CFG_ACTIVE_LOW,           /* active low/high for LED1, RW */
+    RTK_PHY_CTRL_LED_2_CFG_ACTIVE_LOW,           /* active low/high for LED2, RW */
+    RTK_PHY_CTRL_LED_3_CFG_ACTIVE_LOW,           /* active low/high for LED3, RW */
+    RTK_PHY_CTRL_LED_4_CFG_ACTIVE_LOW,           /* active low/high for LED4, RW */
+    RTK_PHY_CTRL_LED_5_CFG_ACTIVE_LOW,           /* active low/high for LED5, RW */
+    RTK_PHY_CTRL_LED_6_CFG_ACTIVE_LOW,           /* active low/high for LED6, RW */
+    RTK_PHY_CTRL_LED_1_CFG_FORCE,                /* LED force mode for LED1, RW */
+    RTK_PHY_CTRL_LED_2_CFG_FORCE,                /* LED force mode for LED2, RW */
+    RTK_PHY_CTRL_LED_3_CFG_FORCE,                /* LED force mode for LED3, RW */
+    RTK_PHY_CTRL_LED_4_CFG_FORCE,                /* LED force mode for LED4, RW */
+    RTK_PHY_CTRL_LED_5_CFG_FORCE,                /* LED force mode for LED5, RW */
+    RTK_PHY_CTRL_LED_6_CFG_FORCE,                /* LED force mode for LED6, RW */
+    RTK_PHY_CTRL_NBASET_802P3BZ_MASK,            /* mask 802.3bz and advert NBASE-T only, RW*/
+    RTK_PHY_CTRL_NBASET,                         /* NBASET-T enable/disable, RW */
+    RTK_PHY_CTRL_NBASET_STATUS,                  /* link is operated at NBASET-T, R */
+    RTK_PHY_CTRL_LOOPBACK_INTERNAL_PMA,          /* internal loopback at PMA, RW */
+    RTK_PHY_CTRL_LOOPBACK_REMOTE,                /* remote loopback, RW */
+    RTK_PHY_CTRL_SERDES_RX_POLARITY,             /* SerDes RX polarity, RW */
+    RTK_PHY_CTRL_SERDES_TX_POLARITY,             /* SerDes TX polarity, RW */
+    RTK_PHY_CTRL_MDI_POLARITY_SWAP,              /* MDI polarity swap, RW  */
+    RTK_PHY_CTRL_MDI_INVERSE,                    /* MDI pin sequence inverse, RW */
+    RTK_PHY_CTRL_RAPID_LINK_FAULT_DETECT,        /* rapid link fault detection enable/disable, RW */
+    RTK_PHY_CTRL_PREAMBLE_RECOVERY,              /* preamble-recovery enable, RW */
+    RTK_PHY_CTRL_SYNCE,                          /* SyncE enable, RW */
+    RTK_PHY_CTRL_SYNCE_0_CLOCK_FREQ,             /* clock frequency for SyncE0, RW */
+    RTK_PHY_CTRL_SYNCE_1_CLOCK_FREQ,             /* clock frequency for SyncE1, RW */
+    RTK_PHY_CTRL_SYNCE_0_RECOVERY_PHY,           /* recovery PHY port for SyncE0, RW */
+    RTK_PHY_CTRL_SYNCE_1_RECOVERY_PHY,           /* recovery PHY port for SyncE1, RW */
+    RTK_PHY_CTRL_SYNCE_0_IDLE_MODE,              /* idle mode for SyncE0, RW */
+    RTK_PHY_CTRL_SYNCE_1_IDLE_MODE,              /* idle mode for SyncE1, RW */
+    RTK_PHY_CTRL_TEMP,                           /* read temperature from thermal meter(bit[18]:sign; [17:10]:integer; [9:0]:decimal), R*/
+    RTK_PHY_CTRL_TEMP_THRESHOLD_HIGH_LOWER,      /* thermal high threshold, RW([18]:sign; [17:10]:integer(degrees Celsius); [9:0]:decimal), for trigger interrupt when temperature lower then this threshold */
+    RTK_PHY_CTRL_TEMP_THRESHOLD_HIGH_HIGHER,     /* thermal high threshold, RW([18]:sign; [17:10]:integer(degrees Celsius); [9:0]:decimal), for trigger interrupt when temperature higher then this threshold */
+	RTK_PHY_CTRL_TEMP_THRESHOLD_LOW_LOWER,       /* thermal  low threshold, RW([18]:sign; [17:10]:integer(degrees Celsius); [9:0]:decimal), for trigger interrupt when temperature lower then this threshold */
+    RTK_PHY_CTRL_TEMP_THRESHOLD_LOW_HIGHER,      /* thermal  low threshold, RW([18]:sign; [17:10]:integer(degrees Celsius); [9:0]:decimal), for trigger interrupt when temperature higher then this threshold */
+    RTK_PHY_CTRL_FAST_RETRAIN,                   /* enable fast retrain ability, RW */
+    RTK_PHY_CTRL_FAST_RETRAIN_LPCOUNT,           /* Counts the number of fast retrains requested by the link partner, R */
+    RTK_PHY_CTRL_FAST_RETRAIN_LDCOUNT,           /* Counts the number of fast retrains requested by the local device, R */
+    RTK_PHY_CTRL_FAST_RETRAIN_STATUS,            /* fast retrain capable at current link(1 for Both local and link-partner have fast retrain capability of current speed), R */
+    RTK_PHY_CTRL_FAST_RETRAIN_NFR,               /* enable NFR ability, RW */
+    RTK_PHY_CTRL_FAST_RETRAIN_NFR_STATUS,        /* NFR capable at current link, R */
+    RTK_PHY_CTRL_COUNTER_CLEAR,                  /* clear counter, W */
+    RTK_PHY_CTRL_SERDES_MODE,                    /* config SerDes mode, RW */
+    RTK_PHY_CTRL_SERDES_UPDTAE,                  /* update SerDes setting for those modes can't auto change speed when link up(do this after MAC side serdes mode change), W */
+    RTK_PHY_CTRL_SERDES_USXGMII_AN,              /* SerDes auto-negotiation enable(1)/disable(0) for USXGMII mode, RW */
+    RTK_PHY_CTRL_SERDES_SGMII_AN,                /* SerDes auto-negotiation enable(1)/disable(0) for SGMII mode, RW */
+    RTK_PHY_CTRL_SERDES_BASEX_AN,                /* SerDes auto-negotiation enable(1)/disable(0) for 1000BASE-X/2.5GBASE-X/5GBASE-X mode, RW */
+    RTK_PHY_CTRL_SERDES_XSGMII_AN,               /* SerDes auto-negotiation enable(1)/disable(0) for XSGMII mode, RW */
+    RTK_PHY_CTRL_SNR_CH0,                        /* Get current SNR value(MSE) of Channel 0, R */  /********************************************************************************************************/
+    RTK_PHY_CTRL_SNR_CH1,                        /* Get current SNR value(MSE) of Channel 1, R */  /* SNR value convertion                                                                                 */
+    RTK_PHY_CTRL_SNR_CH2,                        /* Get current SNR value(MSE) of Channel 2, R */  /********************************************************************************************************/
+    RTK_PHY_CTRL_SNR_CH3,                        /* Get current SNR value(MSE) of Channel 3, R */  /* For 10G/5G/2.5G:                               | For 1G/100M:                                        */
+    RTK_PHY_CTRL_SNR_THRESHOLD_10G_MASTER,       /* SNR threshold(MSE) for 10G Master, RW */       /*   bit [15:11] is integer; [10:0] is decimal    |   bit [15:0] is 16 bits LSB of 17-bit decimal value */
+    RTK_PHY_CTRL_SNR_THRESHOLD_10G_SLAVE,        /* SNR threshold(MSE) for 10G Slave, RW */        /*      SNR = 10*log10(81/MSE)                    |      SNR = 10*log10(2/mse)                          */
+    RTK_PHY_CTRL_SNR_THRESHOLD_5G_MASTER,        /* SNR threshold(MSE) for 5G Master, RW */        /*      MSE = 81/(pow(10,(SNR/10))                |      MSE = 2/(pow (10,(snr/10)))                    */
+    RTK_PHY_CTRL_SNR_THRESHOLD_5G_SLAVE,         /* SNR threshold(MSE) for 5G Slave, RW */         /* Example:                                       | Example:                                            */
+    RTK_PHY_CTRL_SNR_THRESHOLD_2P5G_MASTER,      /* SNR threshold(MSE) for 2.5G Master, RW */      /*   0x2E5= 0000 0.010 1110 0101= 0.361816        |   0x1000= 0.0 0001 0000 0000 0000= 0.031250         */
+    RTK_PHY_CTRL_SNR_THRESHOLD_2P5G_SLAVE,       /* SNR threshold(MSE) for 2.5G Slave, RW */       /*   SNR= 10*log10(81/0.3618)= 23.499968 db       |   SNR= 10*log10(2/0.03125)= 18.061800 db            */
+    RTK_PHY_CTRL_SNR_THRESHOLD_1G,               /* SNR threshold(MSE) for 1G/100M, RW */          /********************************************************************************************************/
+    RTK_PHY_CTRL_REINIT,                         /* Set 1 to reset and reinit port, W */
+    RTK_PHY_CTRL_SKEW_PAIR_B,                    /* Get current skew delay on pair B with respect to physical pair A*/
+    RTK_PHY_CTRL_SKEW_PAIR_C,                    /* Get current skew delay on pair B with respect to physical pair A*/
+    RTK_PHY_CTRL_SKEW_PAIR_D,                    /* Get current skew delay on pair B with respect to physical pair A*/
+    RTK_PHY_CTRL_SERDES_LOOPBACK_REMOTE,         /* remote loopback on SerDes, RW */
+    RTK_PHY_CTRL_RTCT_CABLE_TYPE,                /* RTCT cable type, W */
+    RTK_PHY_CTRL_RTCT_CABLE_FACTOR,              /* RTCT cable factor value to caculate cable length, set 0 to use driver default value, RW */
+    RTK_PHY_CTRL_SERDES_EYE_PARAM_TYPE,          /* serdes mode target for rtk_port_phySdsEyeParam_set/get API, RW */
+	RTK_PHY_CTRL_PTP,                            /* PTP enable, RW */
+    RTK_PHY_CTRL_PTP_DURATION_THRESHOLD,         /* PTP duration threahold(ns) for trigger time operation (falling edge and rising edge), RW */
+    RTK_PHY_CTRL_PTP_REFTIME_TOD_DELAY,          /* PTP ToD delay(ns) for reference time in 16-bit 2's complement format, RW */
+    RTK_PHY_CTRL_PTP_PORT_ROLE,                  /* PTP port role, RW */
+    RTK_PHY_CTRL_PTP_TX_IMBAL,                   /* PTP TX IMBAL(ns), egressTimestamp = egressMeasuredTimestamp + TX_IMBAL, RW */
+    RTK_PHY_CTRL_PTP_RX_IMBAL,                   /* PTP RX IMBAL(ns), ingressTimestamp = ingressMeasuredTimestamp - RX_IMBAL, RW */
+    RTK_PHY_CTRL_PTP_CLOCK_SRC,                  /* PTP clock source select external/internal clock, RW */
+    RTK_PHY_CTRL_LINKDOWN_CNT,                   /* get link down counter (read clear), R */
+    RTK_PHY_CTRL_FATAL_STATUS,                   /* get fatal error status bitmap, R */
+    RTK_PHY_CTRL_FATAL_STATUS_READ_CLEAR,        /* get fatal error status bitmap(read clear), RC */
+    RTK_PHY_CTRL_PTP_PLL_POW_SRC,                /* PTP PLL power source select, RW*/
+    RTK_PHY_CTRL_PTP_PLL_CLK,                    /* PTP PLL clock frequence select, RW*/
+    RTK_PHY_CTRL_PTP_PLL,                        /* PTP PLL enable, RW*/
+    RTK_PHY_CTRL_MACSEC_BYPASS,                  /* Set 1 to bypass MACsec, RW */
+    /* Private/Debug options */
+    RTK_PHY_CTRL_DEBUG_DUMP_DSP,                 /* used by rtk_phy_debug_get */
+    RTK_PHY_CTRL_DEBUG_DUMP_DSP_INIT,            /* used by rtk_phy_debug_get */
+    RTK_PHY_CTRL_DEBUG_DUMP_COUPLING,            /* used by rtk_phy_debug_get */
+    RTK_PHY_CTRL_DEBUG_MDI_PLUG,                 /* get MDI link status, R */
+    RTK_PHY_CTRL_DEBUG_MDIO_PARITY_CHK,          /* get debug conuter for MDIO parity check, R */
+    RTK_PHY_CTRL_MIIM_BCAST,                     /* enable/disable miim broadcast, W*/
+    RTK_PHY_CTRL_MIIM_BCAST_PHYAD,               /* set miim broadcast PHYAD, W*/
+    RTK_PHY_CTRL_SYNCE_PLL,                      /* SyncE output clock source from PLL, W */
+    RTK_PHY_CTRL_IPG_SHRINK,                     /* Enable PHY's IPG shrink when switch enables stacking on the port */
+    RTK_PHY_CTRL_SERDES_USXGMII_AM_PERIOD,       /* get/set SerDes AM period RW */
+    RTK_PHY_CTRL_END
+} rtk_phy_ctrl_t;
+
+
+typedef enum rt_error_common_e
+{
+    RT_ERR_FAILED = -1,                             /* General Error                                                                    */
+
+    /* 0x0000xxxx for common error code */
+    RT_ERR_OK = 0,                                  /* 0x00000000, OK                                                                   */
+    RT_ERR_INPUT = 0xF001,                          /* 0x0000F001, invalid input parameter                                              */
+    RT_ERR_UNIT_ID,                                 /* 0x0000F002, invalid unit id                                                      */
+    RT_ERR_PORT_ID,                                 /* 0x0000F003, invalid port id                                                      */
+    RT_ERR_PORT_MASK,                               /* 0x0000F004, invalid port mask                                                    */
+    RT_ERR_PORT_LINKDOWN,                           /* 0x0000F005, link down port status                                                */
+    RT_ERR_ENTRY_INDEX,                             /* 0x0000F006, invalid entry index                                                  */
+    RT_ERR_NULL_POINTER,                            /* 0x0000F007, input parameter is null pointer                                      */
+    RT_ERR_QUEUE_ID,                                /* 0x0000F008, invalid queue id                                                     */
+    RT_ERR_QUEUE_NUM,                               /* 0x0000F009, invalid queue number                                                 */
+    RT_ERR_BUSYWAIT_TIMEOUT,                        /* 0x0000F00a, busy watting time out                                                */
+    RT_ERR_MAC,                                     /* 0x0000F00b, invalid mac address                                                  */
+    RT_ERR_OUT_OF_RANGE,                            /* 0x0000F00c, input parameter out of range                                         */
+    RT_ERR_CHIP_NOT_SUPPORTED,                      /* 0x0000F00d, functions not supported by this chip model                           */
+    RT_ERR_SMI,                                     /* 0x0000F00e, SMI error                                                            */
+    RT_ERR_NOT_INIT,                                /* 0x0000F00f, The module is not initial                                            */
+    RT_ERR_CHIP_NOT_FOUND,                          /* 0x0000F010, The chip can not found                                               */
+    RT_ERR_NOT_ALLOWED,                             /* 0x0000F011, actions not allowed by the function                                  */
+    RT_ERR_DRIVER_NOT_FOUND,                        /* 0x0000F012, The driver can not found                                             */
+    RT_ERR_SEM_LOCK_FAILED,                         /* 0x0000F013, Failed to lock semaphore                                             */
+    RT_ERR_SEM_UNLOCK_FAILED,                       /* 0x0000F014, Failed to unlock semaphore                                           */
+    RT_ERR_THREAD_EXIST,                            /* 0x0000F015, Thread exist                                                         */
+    RT_ERR_THREAD_CREATE_FAILED,                    /* 0x0000F016, Thread create fail                                                   */
+    RT_ERR_FWD_ACTION,                              /* 0x0000F017, Invalid forwarding Action                                            */
+    RT_ERR_IPV4_ADDRESS,                            /* 0x0000F018, Invalid IPv4 address                                                 */
+    RT_ERR_IPV6_ADDRESS,                            /* 0x0000F019, Invalid IPv6 address                                                 */
+    RT_ERR_PRIORITY,                                /* 0x0000F01a, Invalid Priority value                                               */
+    RT_ERR_FID,                                     /* 0x0000F01b, invalid fid                                                          */
+    RT_ERR_ENTRY_NOTFOUND,                          /* 0x0000F01c, specified entry not found                                            */
+    RT_ERR_DROP_PRECEDENCE,                         /* 0x0000F01d, invalid drop precedence                                              */
+    RT_ERR_NOT_FINISH,                              /* 0x0000F01e, Action not finish, still need to wait                                */
+    RT_ERR_TIMEOUT,                                 /* 0x0000F01f, Time out                                                             */
+    RT_ERR_REG_ARRAY_INDEX_1,                       /* 0x0000F020, invalid index 1 of register array                                    */
+    RT_ERR_REG_ARRAY_INDEX_2,                       /* 0x0000F021, invalid index 2 of register array                                    */
+    RT_ERR_ETHER_TYPE,                              /* 0x0000F022, invalid ether type                                                   */
+    RT_ERR_MBUF_PKT_NOT_AVAILABLE,                  /* 0x0000F023, mbuf->packet is not available                                        */
+    RT_ERR_QOS_INVLD_RSN,                           /* 0x0000F024, invalid pkt to CPU reason                                            */
+    RT_ERR_CB_FUNCTION_EXIST,                       /* 0x0000F025, Callback function exist                                              */
+    RT_ERR_CB_FUNCTION_FULL,                        /* 0x0000F026, Callback function number is full                                     */
+    RT_ERR_CB_FUNCTION_NOT_FOUND,                   /* 0x0000F027, Callback function can not found                                      */
+    RT_ERR_TBL_FULL,                                /* 0x0000F028, The table is full                                                    */
+    RT_ERR_TRUNK_ID,                                /* 0x0000F029, invalid trunk id                                                     */
+    RT_ERR_TYPE,                                    /* 0x0000F02a, invalid type                                                         */
+    RT_ERR_ENTRY_EXIST,                             /* 0x0000F02b, entry exists                                                         */
+    RT_ERR_CHIP_UNDEFINED_VALUE,                    /* 0x0000F02c, chip returned an undefined value                                     */
+    RT_ERR_EXCEEDS_CAPACITY,                        /* 0x0000F02d, exceeds the capacity of hardware                                     */
+    RT_ERR_ENTRY_REFERRED,                          /* 0x0000F02e, entry is still being referred                                        */
+    RT_ERR_OPER_DENIED,                             /* 0x0000F02f, operation denied                                                     */
+    RT_ERR_PORT_NOT_SUPPORTED,                      /* 0x0000F030, functions not supported by this port                                 */
+    RT_ERR_SOCKET,                                  /* 0x0000F031, socket error                                                         */
+    RT_ERR_MEM_ALLOC,                               /* 0x0000F032, insufficient memory resource                                         */
+    RT_ERR_ABORT,                                   /* 0x0000F033, operation aborted                                                    */
+    RT_ERR_DEV_ID,                                  /* 0x0000F034, invalid device id                                                    */
+    RT_ERR_DRIVER_NOT_SUPPORTED,                    /* 0x0000F035, functions not supported by this driver */
+    RT_ERR_NOT_SUPPORTED,                           /* 0x0000F036, functions not supported */
+
+    RT_ERR_COMMON_END = 0xFFFF                      /* The symbol is the latest symbol of common error                                  */
+} rt_error_common_t;
+
+typedef struct rtk_phy_hwpatch_s
+{
+    a_uint8_t    patch_op;
+    a_uint8_t    portmask;
+    a_uint16_t   pagemmd;
+    a_uint16_t   addr;
+    a_uint8_t    msb;
+    a_uint8_t    lsb;
+    a_uint16_t   data;
+} rtk_phy_hwpatch_t;
+
+typedef struct phy_rtl826xb_info_s
+{
+    a_uint32_t sdsModeCfg[RTK_MAX_PORT_PER_UNIT];
+    a_uint8_t  rtctCable[RTK_MAX_PORT_PER_UNIT];
+    a_uint32_t eyeParamTarget[RTK_MAX_PORT_PER_UNIT];
+} phy_rtl826xb_info_t;
+
+
+#define PHY_826XB_LED_MODE_L_10G              (1 << 0)
+#define PHY_826XB_LED_MODE_L_10G_LITE         (1 << 1)
+#define PHY_826XB_LED_MODE_L_5G               (1 << 2)
+#define PHY_826XB_LED_MODE_L_5G_LITE          (1 << 3)
+#define PHY_826XB_LED_MODE_L_2P5G             (1 << 4)
+#define PHY_826XB_LED_MODE_L_2P5G_LITE        (1 << 5)
+#define PHY_826XB_LED_MODE_L_1G               (1 << 6)
+#define PHY_826XB_LED_MODE_L_500M             (1 << 7)
+#define PHY_826XB_LED_MODE_L_100M             (1 << 8)
+#define PHY_826XB_LED_MODE_L_10G_FLASH        (1 << 9)
+#define PHY_826XB_LED_MODE_L_10G_LITE_FLASH   (1 << 10)
+#define PHY_826XB_LED_MODE_L_5G_FLASH         (1 << 11)
+#define PHY_826XB_LED_MODE_L_5G_LITE_FLASH    (1 << 12)
+#define PHY_826XB_LED_MODE_L_2P5G_FLASH       (1 << 13)
+#define PHY_826XB_LED_MODE_L_2P5G_LITE_FLASH  (1 << 14)
+#define PHY_826XB_LED_MODE_L_1G_FLASH         (1 << 15)
+
+#define PHY_826XB_LED_MODE_H_500M_FLASH       (1 << 0)
+#define PHY_826XB_LED_MODE_H_100M_FLASH       (1 << 1)
+#define PHY_826XB_LED_MODE_H_RX_ACT           (1 << 2)
+#define PHY_826XB_LED_MODE_H_TX_ACT           (1 << 3)
+#define PHY_826XB_LED_MODE_H_LITE_FLASH       (1 << 4)
+#define PHY_826XB_LED_MODE_H_LITE             (1 << 5)
+#define PHY_826XB_LED_MODE_H_DUPLEX           (1 << 6)
+#define PHY_826XB_LED_MODE_H_MASTER           (1 << 7)
+#define PHY_826XB_LED_MODE_H_TRAINING         (1 << 8)
+#define PHY_826XB_LED_MODE_H_LINK_EN          (1 << 9)
+
+
+a_uint16_t
+phy_common_general_reg_mmd_get(a_uint32_t unit, a_uint32_t port, a_uint16_t mmdAddr, a_uint16_t mmdReg);
+
+sw_error_t
+phy_common_general_reg_mmd_set(a_uint32_t unit, a_uint32_t port, a_uint16_t mmdAddr, a_uint16_t mmdReg, a_uint16_t data);
+
+sw_error_t
+phy_826xb_autoNegoEnable_set(a_uint32_t unit, a_uint32_t port);
+
+sw_error_t rtl826x_phy_get_status(a_uint32_t dev_id, a_uint32_t phy_id, struct port_phy_status *phy_status);
+sw_error_t phy_826xb_poweroff(a_uint32_t dev_id, a_uint32_t phy_id);
+sw_error_t phy_826xb_poweron(a_uint32_t dev_id, a_uint32_t phy_id);
+sw_error_t phy_826xb_phy_id_get(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t *phy_data);
+
+struct rtl_phy_info* rtl_phy_info_get(a_uint32_t phy_addr);
+int rtl_phy_init(a_uint32_t dev_id, a_uint32_t port_bmp);
+void rtl_phydev_deinit(a_uint32_t dev_id, a_uint32_t port_id);
+void rtl_phy_driver_unregister(void);
+a_uint32_t phy_rtl826xb_patch(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset);
+sw_error_t phy_826xb_ctrl_set(a_uint32_t unit, a_uint32_t port, rtk_phy_ctrl_t ctrl_type, a_uint16_t value);
+a_int32_t phy_rtl826xb_broadcast_patch(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset);
+sw_error_t phy_common_c45_reset_set(a_uint32_t unit, a_uint32_t port);
+sw_error_t phy_826xb_autoNegoAbility_set(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t autoneg);
+sw_error_t phy_826xb_restart_autoneg(a_uint32_t dev_id, a_uint32_t port);
+void rtl_phydev_init(a_uint32_t dev_id, a_uint32_t port_id);
+
+
+#endif /* __HAL_PHY_PHY_RTL826XB_H__ */
\ No newline at end of file
diff --git a/make/linux_opt.mk b/make/linux_opt.mk
index 875d1b47..62115f32 100755
--- a/make/linux_opt.mk
+++ b/make/linux_opt.mk
@@ -176,6 +176,10 @@ ifeq (TRUE, $(IN_AQUANTIA_PHY))
   MODULE_CFLAG += -DIN_AQUANTIA_PHY
 endif
 
+ifeq (TRUE, $(IN_RTL_PHY))
+  MODULE_CFLAG += -DIN_RTL_PHY
+endif
+
 ifeq (TRUE, $(IN_QCA803X_PHY))
   MODULE_CFLAG += -DIN_QCA803X_PHY
 endif
diff --git a/src/hsl/phy/Makefile b/src/hsl/phy/Makefile
index b36d7205..120b4643 100755
--- a/src/hsl/phy/Makefile
+++ b/src/hsl/phy/Makefile
@@ -60,6 +60,12 @@ ifeq (TRUE, $(IN_QCA803X_PHY))
     SRC_LIST += qca803x_phy.c
 endif
 
+ifeq (TRUE, $(IN_RTL_PHY))
+    SRC_LIST += rtl826xb_phy.c
+    SRC_LIST += phy_rtl826xb_patch.c
+    SRC_LIST += rtl.c
+endif
+
 ifeq (TRUE, $(IN_QCA808X_PHY))
     SRC_LIST += qca808x_phy.c
     SRC_LIST += qca808x.c
diff --git a/src/hsl/phy/hsl_phy.c b/src/hsl/phy/hsl_phy.c
index 219d2302..f8e805fc 100755
--- a/src/hsl/phy/hsl_phy.c
+++ b/src/hsl/phy/hsl_phy.c
@@ -37,6 +37,9 @@
 #ifdef IN_AQUANTIA_PHY
 #include <aquantia_phy.h>
 #endif
+#ifdef IN_RTL_PHY
+#include <phy_rtl826xb.h>
+#endif
 #ifdef IN_QCA803X_PHY
 #include <qca803x_phy.h>
 #endif
@@ -96,6 +99,11 @@ phy_driver_instance_t ssdk_phy_driver[] =
 	#else
 	{MPGE_PHY_CHIP, {0}, NULL, NULL, NULL},
 	#endif
+	#ifdef IN_RTL_PHY
+	{RTL_PHY_CHIP, {0}, NULL, rtl_phy_init, NULL},
+	#else
+	{RTL_PHY_CHIP, {0}, NULL, NULL, NULL},
+	#endif
 	#ifdef IN_QCA808X_PHY
 /*qca808x_start*/
 	{QCA808X_PHY_CHIP, {0}, NULL, qca808x_phy_init, qca808x_phy_exit},
@@ -290,6 +298,9 @@ phy_type_t hsl_phytype_get_by_phyid(a_uint32_t dev_id, a_uint32_t phy_id)
 		case MP_GEPHY:
 			phytype = MPGE_PHY_CHIP;
 			break;
+		case RTL_PHY:
+			phytype = RTL_PHY_CHIP;
+			break;
 		case QCA8084_PHY:
 /*qca808x_start*/
 		case QCA8081_PHY_V1_1:
@@ -684,8 +695,8 @@ hsl_port_phy_mode_set(a_uint32_t dev_id, a_uint32_t port_id,
 	a_uint32_t phy_addr = 0;
 	hsl_phy_ops_t *phy_drv;
 
-	SW_RTN_ON_NULL(phy_drv = hsl_phy_api_ops_get (dev_id, port_id));
-	if (NULL == phy_drv->phy_interface_mode_set)
+	phy_drv = hsl_phy_api_ops_get (dev_id, port_id);
+	if (NULL == phy_drv || NULL == phy_drv->phy_interface_mode_set)
 	{
 		/*PHY driver did not register phy_interface_mode_set,
 		so no need to configure PHY interface mode*/
@@ -1210,6 +1221,58 @@ a_uint32_t hsl_port_mode_to_uniphy_mode(a_uint32_t dev_id,
 	return uniphy_mode;
 }
 
+a_uint32_t hsl_uniphy_mode_to_port_mode(a_uint32_t dev_id, a_uint32_t port_id,
+	a_uint32_t uniphy_mode)
+{
+	a_uint32_t port_mode = 0;
+
+	switch(uniphy_mode)
+	{
+		case PORT_WRAPPER_PSGMII:
+		case PORT_WRAPPER_PSGMII_FIBER:
+			if(port_id >= SSDK_PHYSICAL_PORT1 && port_id <= SSDK_PHYSICAL_PORT4)
+				port_mode = PHY_PSGMII_BASET;
+			if(port_id == SSDK_PHYSICAL_PORT5) {
+				if(uniphy_mode == PORT_WRAPPER_PSGMII)
+					port_mode = PHY_PSGMII_BASET;
+				else
+					port_mode = PHY_PSGMII_FIBER;
+			}
+			break;
+		case PORT_WRAPPER_QSGMII:
+			port_mode = PORT_QSGMII;
+			break;
+		case PORT_WRAPPER_SGMII_PLUS:
+			port_mode = PORT_SGMII_PLUS;
+			break;
+		case PORT_WRAPPER_USXGMII:
+			port_mode = PORT_USXGMII;
+			break;
+		case PORT_WRAPPER_10GBASE_R:
+			port_mode = PORT_10GBASE_R;
+			break;
+		case PORT_WRAPPER_SGMII_CHANNEL0:
+		case PORT_WRAPPER_SGMII_CHANNEL1:
+		case PORT_WRAPPER_SGMII_CHANNEL4:
+			port_mode = PHY_SGMII_BASET;
+			break;
+		case PORT_WRAPPER_SGMII_FIBER:
+			port_mode = PORT_SGMII_FIBER;
+			break;
+		case PORT_WRAPPER_UQXGMII:
+		case PORT_WRAPPER_UDXGMII:
+			port_mode = PORT_UQXGMII;
+			break;
+		case PORT_WRAPPER_MAX:
+			port_mode = PORT_INTERFACE_MODE_MAX;
+			break;
+		default:
+			return SW_NOT_SUPPORTED;
+	}
+
+	return port_mode;
+}
+
 a_uint32_t hsl_port_to_uniphy(a_uint32_t dev_id, a_uint32_t port_id)
 {
 	a_uint32_t uniphy_index = SSDK_MAX_UNIPHY_INSTANCE;
@@ -1319,6 +1382,124 @@ hsl_port_phy_interface_mode_status_get(a_uint32_t dev_id, a_uint32_t port_id,
 	return SW_OK;
 }
 
+sw_error_t
+hsl_port_phy_power_on(a_uint32_t dev_id, fal_port_t port_id)
+{
+	sw_error_t rv = SW_OK;
+	a_uint32_t phy_addr = 0;
+	hsl_phy_ops_t *phy_drv = NULL;
+
+	HSL_DEV_ID_CHECK(dev_id);
+
+	if (A_TRUE != hsl_port_prop_check (dev_id, port_id, HSL_PP_PHY))
+	{
+		return SW_BAD_PARAM;
+	}
+
+	SW_RTN_ON_NULL (phy_drv = hsl_phy_api_ops_get (dev_id, port_id));
+	if (NULL == phy_drv->phy_power_on)
+		return SW_NOT_SUPPORTED;
+
+	rv = hsl_port_prop_get_phyid (dev_id, port_id, &phy_addr);
+	SW_RTN_ON_ERROR (rv);
+
+	return phy_drv->phy_power_on(dev_id, phy_addr);
+}
+
+sw_error_t
+hsl_port_phy_power_off(a_uint32_t dev_id, fal_port_t port_id)
+{
+	sw_error_t rv = SW_OK;
+	a_uint32_t phy_addr = 0;
+	hsl_phy_ops_t *phy_drv = NULL;
+
+	HSL_DEV_ID_CHECK(dev_id);
+
+	if (A_TRUE != hsl_port_prop_check (dev_id, port_id, HSL_PP_PHY))
+	{
+		return SW_BAD_PARAM;
+	}
+
+	SW_RTN_ON_NULL (phy_drv = hsl_phy_api_ops_get (dev_id, port_id));
+	if (NULL == phy_drv->phy_power_off)
+		return SW_NOT_SUPPORTED;
+
+	rv = hsl_port_prop_get_phyid (dev_id, port_id, &phy_addr);
+	SW_RTN_ON_ERROR (rv);
+
+	return phy_drv->phy_power_off(dev_id, phy_addr);
+
+}
+/*qca808x_end*/
+sw_error_t
+hsl_port_phy_pll_on(a_uint32_t dev_id, a_uint32_t port_id)
+{
+	sw_error_t rv = SW_OK;
+	a_uint32_t phy_addr = 0;
+	hsl_phy_ops_t *phy_drv = NULL;
+
+	HSL_DEV_ID_CHECK(dev_id);
+
+	if (A_TRUE != hsl_port_prop_check(dev_id, port_id, HSL_PP_PHY))
+		return SW_BAD_PARAM;
+
+	SW_RTN_ON_NULL (phy_drv = hsl_phy_api_ops_get(dev_id, port_id));
+	if (NULL == phy_drv->phy_pll_on)
+		return SW_NOT_SUPPORTED;
+
+	rv = hsl_port_prop_get_phyid(dev_id, port_id, &phy_addr);
+	SW_RTN_ON_ERROR (rv);
+
+	rv = phy_drv->phy_pll_on(dev_id, phy_addr);
+	return rv;
+}
+
+sw_error_t
+hsl_port_phy_pll_off(a_uint32_t dev_id, a_uint32_t port_id)
+{
+	sw_error_t rv = SW_OK;
+	a_uint32_t phy_addr = 0;
+	hsl_phy_ops_t *phy_drv = NULL;
+
+	HSL_DEV_ID_CHECK(dev_id);
+
+	if (A_TRUE != hsl_port_prop_check(dev_id, port_id, HSL_PP_PHY))
+		return SW_BAD_PARAM;
+
+	SW_RTN_ON_NULL (phy_drv = hsl_phy_api_ops_get(dev_id, port_id));
+	if (NULL == phy_drv->phy_pll_off)
+		return SW_NOT_SUPPORTED;
+
+	rv = hsl_port_prop_get_phyid(dev_id, port_id, &phy_addr);
+	SW_RTN_ON_ERROR (rv);
+
+	rv = phy_drv->phy_pll_off(dev_id, phy_addr);
+	return rv;
+}
+
+sw_error_t
+hsl_port_phy_ldo_set(a_uint32_t dev_id, a_uint32_t port_id, a_bool_t enable)
+{
+	sw_error_t rv = SW_OK;
+	a_uint32_t phy_addr = 0;
+	hsl_phy_ops_t *phy_drv = NULL;
+
+	HSL_DEV_ID_CHECK(dev_id);
+
+	if (A_TRUE != hsl_port_prop_check(dev_id, port_id, HSL_PP_PHY))
+		return SW_BAD_PARAM;
+
+	SW_RTN_ON_NULL (phy_drv = hsl_phy_api_ops_get(dev_id, port_id));
+	if (NULL == phy_drv->phy_ldo_set)
+		return SW_NOT_SUPPORTED;
+
+	rv = hsl_port_prop_get_phyid(dev_id, port_id, &phy_addr);
+	SW_RTN_ON_ERROR (rv);
+
+	rv = phy_drv->phy_ldo_set(dev_id, phy_addr, enable);
+	return rv;
+}
+/*qca808x_start*/
 sw_error_t
 hsl_port_phy_counter_set(a_uint32_t dev_id, a_uint32_t port_id, a_bool_t enable)
 {
diff --git a/src/hsl/phy/phy_rtl826xb_patch.c b/src/hsl/phy/phy_rtl826xb_patch.c
new file mode 100644
index 00000000..21c9b38d
--- /dev/null
+++ b/src/hsl/phy/phy_rtl826xb_patch.c
@@ -0,0 +1,1651 @@
+
+/*
+ * Copyright (C) 2009-2021 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * This program is the proprietary software of Realtek Semiconductor
+ * Corporation and/or its licensors, and only be used, duplicated,
+ * modified or distributed under the authorized license from Realtek.
+ *
+ * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
+ * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+ *
+ * $Revision: $
+ * $Date: $
+ *
+ * Purpose : PHY 826XB/8261N Driver APIs.
+ *
+ * Feature : PHY 826XB/8261N Driver APIs
+ *
+ */
+
+/*
+ * Include Files
+ */
+#include "phy_common.h"
+#include "phy_rtl826xb.h"
+/*
+ * Symbol Definition
+ */
+
+#define PHY_PATCH_OP_NORMAL 0
+#define PHY_PATCH_OP_BCAST  1
+#define PHY_PATCH_WAIT_TIMEOUT     1000000
+
+#define PHY_PATCH_LOG    LOG_INFO
+
+
+#define RTL8261N_C_FW_VER     0x0001
+#define RTL8261N_C_MAIN_VER   0x1
+#define RTL8261N_C_SW_VER     0x1
+#define RTL8261N_C_TOP_VER    0x0101
+#define RTL8261N_C_AFEFW_VER  0x0101
+
+
+#define RTK_HWPATCH_OP_UNKNOWN 0
+#define RTK_HWPATCH_OP_SDS     1
+#define RTK_HWPATCH_OP_PHY     2
+#define RTK_HWPATCH_OP_PHYW    3
+#define RTK_HWPATCH_OP_ALGO    4
+#define RTK_HWPATCH_OP_TOP     5
+#define RTK_HWPATCH_OP_MMD     6
+#define RTK_HWPATCH_OP_DATARAM 7
+
+rtk_phy_hwpatch_t rtl8261N_C_patch_fwpr_conf[] = {
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x8023},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x3802},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xb82e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0001},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb820, 15,  0, 0x0090},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa016},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0020},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa012},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa014},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8029},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8217},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82d0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82f9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8322},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8322},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8322},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcb0a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4127},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c0f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b05},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0d28},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c0f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b0a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0d18},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0f73},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8034},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8031},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1bf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd06d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1dd},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd06d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd06e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fba},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd05a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60cf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60f1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6113},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6135},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6157},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf004},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf002},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x142d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0ccf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b40},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c24},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa340},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x147c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1435},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1485},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa304},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa8c0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8810},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa310},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cfc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0224},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0ca0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0480},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa340},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd162},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fba},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8840},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1c4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd045},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fba},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6127},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f3b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x88c0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x800a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8350},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x84a0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffb6},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xb920},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd33},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x7fb4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9920},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6065},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f94},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffee},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xb820},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x7fa5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9820},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x800a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x147c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa108},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1435},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8108},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1485},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa2fc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa304},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8880},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0440},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd34},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b80},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xac3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0d08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa810},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa480},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa604},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x80bb},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd19f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x63f4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4368},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b40},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8d38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x80d7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x80d4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1f4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1b7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1c6},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6074},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4056},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf004},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x61fc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xfff9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4070},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x81a4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xae80},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x81a4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd05a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60cf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60f1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6113},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6135},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6157},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf004},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf002},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x142d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0ccf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b40},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c24},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa340},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x147c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1435},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1485},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa304},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa8c0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8810},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa310},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cfc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0224},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0ca0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0480},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8604},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd35},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd162},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fba},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8840},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1c4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd045},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fba},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6127},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f3b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x88c0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x800a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8350},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x84a0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffb8},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xbb80},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5fb4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xb920},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd36},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x7fb4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9920},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9b80},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6065},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f94},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffe8},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xb820},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd71f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x7fa5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9820},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x800a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x147c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa108},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1435},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8108},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1485},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa2fc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa304},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8880},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0440},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd37},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b80},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xac3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0d08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa810},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa480},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa604},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x817e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x817b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f28},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0cc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b40},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8d38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x819a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8197},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd189},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f28},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c0f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b05},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60cf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60f1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6113},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6135},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6157},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf004},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf002},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce08},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x142d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa180},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd38},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x81d4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x81cc},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf013},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1b7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd13b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd055},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa302},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f28},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c12},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8206},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x81fe},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf013},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd040},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd16b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f2a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x087a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x646d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8231},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8227},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf01a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf017},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f29},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60cf},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x60f1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6113},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6135},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6157},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf008},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf004},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf002},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xce06},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x142d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8bc0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c3f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c09},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa120},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa310},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xa420},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd3b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x65ad},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x43c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x827b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8273},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf024},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd15d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf021},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1c6},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf01c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd15d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf019},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf014},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf011},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x828e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x828b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1e5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf009},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd191},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd16b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1418},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1463},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f7a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd706},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5f2c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40e7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c0f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b05},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c03},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1502},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0c0f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0b0a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x9503},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xcd3c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x644d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x43c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82c1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82b9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf019},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf016},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf011},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd13e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x4098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf009},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd049},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd048},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0956},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x2969},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82f5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82eb},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x82e1},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd15c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf01a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf017},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd13e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd199},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x09a0},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x2969},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x831e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x37c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x8314},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x33a9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x830a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd15d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf01a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf017},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd16b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf00d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd700},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x40c7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd702},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x6098},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf006},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd17a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xf003},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd1b7},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xd04a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x1800},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0a39},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa10e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffff},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa10c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffff},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa10a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0xffff},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa108},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0a12},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa106},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0979},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa104},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x089f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa102},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0692},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa100},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0f60},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0xa110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x001f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb820, 15,  0, 0x0010},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb896, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb892, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc10b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5d5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc10c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5cd},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc10d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5d5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc10e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5c9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc10f},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5d5},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc110},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0xd5ee},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc149},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x0808},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc14a},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x0810},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc14b},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x0808},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc14c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x0813},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc14d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x0808},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb88e, 15,  0, 0xc14e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb890, 15,  0, 0x08e9},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb896, 15,  0, 0x0001},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb82e, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x8023},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0000},
+};
+
+rtk_phy_hwpatch_t rtl8261N_C_patch_fwlm_conf[] = {
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x8165},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0x2274},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x8167},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0x3385},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x816e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0xaeca},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x8139},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0x29c4},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x8125},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0x6567},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87c, 15,  0, 0x827e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb87e, 15,  0, 0x683c},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x8367},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x5d6e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x817d},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0758},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xb516, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa436, 15,  0, 0x801e},
+    {RTK_HWPATCH_OP_PHY, 0xff ,0x00, 0xa438, 15,  0, 0x0001},
+};
+
+rtk_phy_hwpatch_t rtl8261N_C_patch_afe_conf[] = {
+};
+
+rtk_phy_hwpatch_t rtl8261N_C_patch_sds_conf[] = {
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0012, 15,  0, 0x881f},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0013, 15,  0, 0x003f},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0014, 15,  0, 0x003f},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0015, 15,  0, 0x003f},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0016, 15,  0, 0x001f},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x06, 0x000d, 15,  0, 0x0f00},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x06, 0x000e, 15,  0, 0x3f5a},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x07, 0x0010, 15,  0, 0x8003},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x06, 0x001d, 15,  0, 0x0600},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x21, 0x0000, 15,  0, 0x4902},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x21, 0x0008, 15,  0, 0x0fc0},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x21, 0x0009, 15,  0, 0x33f0},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x21, 0x000c, 15,  0, 0x08bf},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x21, 0x0012, 15,  0, 0x8000},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x36, 0x0007, 15,  0, 0x04c0},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x36, 0x0008, 15,  0, 0x2000},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x000c, 15,  0, 0xaa17},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x000d, 15,  0, 0xfe40},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x0015, 15,  0, 0x7a41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2e, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x0000, 15,  0, 0x1f00},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x0001, 15,  0, 0x2800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x0011, 15,  0, 0x3000},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2f, 0x001e, 15,  0, 0x0500},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x000c, 15,  0, 0xa517},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x000d, 15,  0, 0xfe41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x0015, 15,  0, 0x7a41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x34, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x0000, 15,  0, 0x1f80},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x0001, 15,  0, 0x0800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x0011, 15,  0, 0x3001},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x35, 0x001e, 15,  0, 0x0100},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x000c, 15,  0, 0xa517},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x000d, 15,  0, 0xfe41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x0015, 15,  0, 0x7a61},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2c, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x0000, 15,  0, 0x1f80},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x0001, 15,  0, 0x0800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x0011, 15,  0, 0x3001},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x2d, 0x001e, 15,  0, 0x0100},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x000c, 15,  0, 0xa514},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x000d, 15,  0, 0xfe43},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x0015, 15,  0, 0x7a61},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x28, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x0000, 15,  0, 0x1f80},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x0001, 15,  0, 0x0800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x0011, 15,  0, 0x3001},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x29, 0x001e, 15,  0, 0x0100},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x000c, 15,  0, 0xa514},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x000d, 15,  0, 0xfe43},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x0015, 15,  0, 0x7a41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x26, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x0000, 15,  0, 0x1f80},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x0001, 15,  0, 0x0800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x0011, 15,  0, 0x3001},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x27, 0x001e, 15,  0, 0x0100},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x000b, 15,  0, 0x2390},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x000c, 15,  0, 0xa514},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x000d, 15,  0, 0xfe43},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x000e, 15,  0, 0x12f4},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x0011, 15,  0, 0xf2ad},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x0015, 15,  0, 0x7a41},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x24, 0x0016, 15,  0, 0x0041},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x0000, 15,  0, 0x1f80},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x0001, 15,  0, 0x0800},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x0002, 15,  0, 0x0fc8},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x0011, 15,  0, 0x3001},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x0013, 15,  0, 0xf400},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x25, 0x001e, 15,  0, 0x0100},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0012, 15,  0, 0x880d},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0013, 15,  0, 0x0024},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0014, 15,  0, 0x0036},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0015, 15,  0, 0x0035},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x18, 0x0016, 15,  0, 0x001a},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x1f, 0x0000, 15,  0, 0x001b},
+    {RTK_HWPATCH_OP_SDS, 0xff ,0x1f, 0x0000, 15,  0, 0x0000},
+};
+
+rtk_phy_hwpatch_t rtl8261N_C_patch_top_conf[] = {
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x02, 0x0014, 15,  0, 0x0005},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x02, 0x0015, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x02, 0x0016, 15,  0, 0x0280},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x02, 0x0017, 15,  0, 0x0014},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0010, 15,  0, 0x0300},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0011, 15,  0, 0x01ff},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0012, 15,  0, 0x000c},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0013, 15,  0, 0x01ff},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0014, 15,  0, 0x0200},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0015, 15,  0, 0x0015},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0016, 15,  0, 0x0200},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x03, 0x0017, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x04, 0x0010, 15,  0, 0x0000},
+    {RTK_HWPATCH_OP_TOP, 0xff ,0x0d, 0x0017,  8,  5, 0x0006},
+};
+
+
+/*
+ * Data Declaration
+ */
+
+/*
+ * Macro Declaration
+ */
+
+/*
+ * Function Declaration
+ */
+
+a_uint32_t
+_phy_rtl826xb_patch_mask(a_uint8_t msb, a_uint8_t lsb)
+{
+    a_uint16_t val = 0;
+    a_uint8_t    i = 0;
+
+    for (i = lsb; i <= msb; i++)
+    {
+        val |= (1 << i);
+    }
+    return val;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_mask_get(a_uint8_t msb, a_uint8_t lsb, a_uint16_t *mask)
+{
+    if ((msb > 15) || (lsb > 15) || (msb < lsb))
+    {
+        return RT_ERR_FAILED;
+    }
+    *mask = _phy_rtl826xb_patch_mask(msb, lsb);
+    return RT_ERR_OK;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_wait(a_uint32_t unit, a_uint32_t  port, a_uint16_t mmdAddr, a_uint16_t mmdReg, a_uint32_t data, a_uint32_t mask, a_uint8_t bcast_op)
+{
+    
+    a_uint16_t rData = 0;
+    a_uint32_t cnt = 0;
+    
+   
+
+
+    if (bcast_op == PHY_PATCH_OP_BCAST)
+    {
+        phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST, 0);
+     
+
+	
+	do
+	{
+		rData = phy_common_general_reg_mmd_get(unit, port, mmdAddr, mmdReg);
+		
+	
+		if (++cnt >= PHY_PATCH_WAIT_TIMEOUT)
+		{
+			return RT_ERR_TIMEOUT;
+		}
+	}while ((rData & mask) != data);
+	
+
+        mdelay(1);
+        //for port in same SMI bus, set mdio broadcast ENABLE
+	
+	phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST_PHYAD, port);
+	
+	
+	phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST, 1);
+	
+    }
+    else
+    {
+        do
+        {
+            rData = phy_common_general_reg_mmd_get(unit, port, mmdAddr, mmdReg);
+              
+
+            if (++cnt >= PHY_PATCH_WAIT_TIMEOUT)
+            {
+             
+                return RT_ERR_TIMEOUT;
+            }
+            mdelay(1);
+        }while ((rData & mask) != data);
+    }
+
+    return RT_ERR_OK;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_wait_not_equal(a_uint32_t unit, a_uint32_t  port, a_uint16_t mmdAddr, a_uint16_t mmdReg, a_uint16_t data, a_uint16_t mask, a_uint8_t bcast_op)
+{
+  
+    a_uint16_t rData = 0;
+    a_uint16_t cnt = 0;
+
+    
+
+    if (bcast_op == PHY_PATCH_OP_BCAST)
+    {
+        phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST, 0);
+       
+		do
+		{
+			rData = phy_common_general_reg_mmd_get(unit, port, mmdAddr, mmdReg);
+			
+		
+			if (++cnt >= PHY_PATCH_WAIT_TIMEOUT)
+			{
+				
+				return RT_ERR_TIMEOUT;
+			}
+		}while ((rData & mask) == data);
+		
+		
+        mdelay(1);
+        //for port in same SMI bus, set mdio broadcast ENABLE
+       
+		phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST_PHYAD, port);
+		
+		
+		phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_MIIM_BCAST, 1);
+		
+		
+    }
+    else
+    {
+        do
+        {
+            rData = phy_common_general_reg_mmd_get(unit, port, mmdAddr, mmdReg);
+             
+
+            if (++cnt >= PHY_PATCH_WAIT_TIMEOUT)
+            {
+
+                return RT_ERR_TIMEOUT;
+            }
+            mdelay(1);
+        }while ((rData & mask) == data);
+    }
+
+    return RT_ERR_OK;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_top_get(a_uint32_t unit, a_uint32_t  port, a_uint16_t topPage, a_uint16_t topReg, a_uint16_t *pData)
+{
+    
+    a_uint16_t rData = 0;
+    a_uint16_t topAddr = (topPage * 8) + (topReg - 16);
+
+    rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, topAddr);
+      
+    *pData = rData;
+    return RT_ERR_OK;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_top_set(a_uint32_t unit, a_uint32_t  port, a_uint32_t topPage, a_uint32_t topReg, a_uint16_t wData)
+{
+    
+    a_uint32_t topAddr = (topPage * 8) + (topReg - 16);
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, topAddr, wData);
+     
+    return RT_ERR_OK;
+}
+
+a_int32_t
+_phy_rtl826xb_patch_sds_get(a_uint32_t unit, a_uint32_t  port, a_uint16_t sdsPage, a_uint16_t sdsReg, a_uint16_t *pData)
+{
+    a_int32_t  ret = 0;
+    a_uint16_t rData = 0;
+    a_uint16_t sdsAddr = 0x8000 + (sdsReg << 6) + sdsPage;
+
+    if ((ret = _phy_rtl826xb_patch_top_set(unit, port, 40, 19, sdsAddr)) != RT_ERR_OK)
+        return ret;
+    if ((ret = _phy_rtl826xb_patch_top_get(unit, port, 40, 18, &rData)) != RT_ERR_OK)
+        return ret;
+    *pData = rData;
+    return _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND1, 0x143, 0, RTLBIT_15, PHY_PATCH_OP_NORMAL);
+}
+
+a_int32_t
+_phy_rtl826xb_patch_sds_set(a_uint32_t unit, a_uint32_t  port, a_uint16_t sdsPage, a_uint16_t sdsReg, a_uint16_t wData, a_uint8_t bcast)
+{
+    a_int32_t  ret = 0;
+    a_uint16_t sdsAddr = 0x8800 + (sdsReg << 6) + sdsPage;
+
+    if ((ret = _phy_rtl826xb_patch_top_set(unit, port, 40, 17, wData)) != RT_ERR_OK)
+        return ret;
+    if ((ret = _phy_rtl826xb_patch_top_set(unit, port, 40, 19, sdsAddr)) != RT_ERR_OK)
+        return ret;
+    return _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND1, 0x143, 0, RTLBIT_15, bcast);
+}
+
+a_int32_t _phy_rtl826xb_patch_data_ram_write(a_uint32_t unit, a_uint32_t port, a_uint32_t addr, a_uint32_t data)
+{
+
+    a_uint16_t rData = 0, wData = 0;
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB88E, addr);
+      
+
+    rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xB890);
+       
+
+
+    if ((addr % 2) == 0)
+    {
+        wData = REG32_FIELD_SET(rData, data, 8, 0xFF00);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB890, wData);
+            
+    }
+    else
+    {
+        wData = REG32_FIELD_SET(rData, data, 0, 0x00FF);
+       phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB890, wData);
+       
+    }
+
+    return RT_ERR_OK;
+}
+
+a_int32_t
+phy_rtl826xb_patch_process_op(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset, rtk_phy_hwpatch_t *op, a_uint8_t bcast)
+{
+    a_uint16_t mask = 0;
+    a_uint16_t rData = 0, wData = 0;
+    if ((op->portmask & (1 << portOffset)) == 0)
+    {
+        return RT_ERR_ABORT;
+    }
+
+    _phy_rtl826xb_patch_mask_get(op->msb, op->lsb, &mask);
+    
+
+    switch (op->patch_op)
+    {
+        case RTK_HWPATCH_OP_PHY:
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, op->addr);
+                  
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, op->addr, wData);
+             
+
+            break;
+
+        case RTK_HWPATCH_OP_MMD:
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                rData = phy_common_general_reg_mmd_get(unit, port, op->pagemmd, op->addr);
+                   
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+            phy_common_general_reg_mmd_set(unit, port, op->pagemmd, op->addr, wData);
+              
+
+            break;
+
+        case RTK_HWPATCH_OP_TOP:
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                _phy_rtl826xb_patch_top_get(unit, port, op->pagemmd, op->addr, &rData);
+                
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+            _phy_rtl826xb_patch_top_set(unit, port, op->pagemmd, op->addr, wData);
+                
+
+            break;
+
+        case RTK_HWPATCH_OP_SDS:
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                _phy_rtl826xb_patch_sds_get(unit, port, op->pagemmd, op->addr, &rData);
+                   
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+
+            _phy_rtl826xb_patch_sds_set(unit, port, op->pagemmd, op->addr, wData, bcast);
+                
+
+            break;
+
+        case RTK_HWPATCH_OP_PHYW:
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, op->addr);
+                    
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, op->addr, wData);
+                
+            break;
+
+        case RTK_HWPATCH_OP_ALGO:
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, op->addr);
+               
+            if ((op->msb != 15) || (op->lsb != 0))
+            {
+                rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xB87E);
+                    
+            }
+            wData = REG32_FIELD_SET(rData, op->data, op->lsb, mask);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, wData);
+               
+            break;
+
+        case RTK_HWPATCH_OP_DATARAM:
+            _phy_rtl826xb_patch_data_ram_write(unit, port, op->addr, op->data);
+               
+            break;
+
+        case RTK_HWPATCH_OP_UNKNOWN:
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    return RT_ERR_OK;
+}
+
+a_int32_t
+phy_rtl826xb_patch_op(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset, a_uint8_t patch_op, a_uint8_t portmask, a_uint16_t pagemmd, a_uint16_t addr, a_uint8_t msb, a_uint8_t lsb, a_uint16_t data)
+{
+    rtk_phy_hwpatch_t op;
+
+    op.patch_op = patch_op;
+    op.portmask = portmask;
+    op.pagemmd  = pagemmd;
+    op.addr     = addr;
+    op.msb      = msb;
+    op.lsb      = lsb;
+    op.data     = data;
+
+    return phy_rtl826xb_patch_process_op(unit, port, portOffset, &op, PHY_PATCH_OP_NORMAL);
+}
+
+a_int32_t _phy_rtl826xb_patch_process(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset, rtk_phy_hwpatch_t *pPatch, a_int32_t size, a_uint32_t *cnt, a_uint8_t bcast)
+{
+    a_int32_t i = 0;
+    a_int32_t ret = 0;
+    a_int32_t n;
+    rtk_phy_hwpatch_t *patch = pPatch;
+    if (size <= 0)
+    {
+        *cnt = 0;
+        return RT_ERR_OK;
+    }
+    n = size/sizeof(rtk_phy_hwpatch_t);
+
+    for (i = 0; i < n; i++)
+    {
+        ret = phy_rtl826xb_patch_process_op(unit, port, portOffset, &patch[i], bcast);
+        if ((ret != RT_ERR_ABORT) && (ret != RT_ERR_OK))
+        {
+            
+            return ret;
+        }
+    }
+    *cnt = i;
+    return RT_ERR_OK;
+}
+
+a_int32_t _phy_rtl826xb_patch(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset, a_uint8_t bcast)
+{
+    a_int32_t ret = 0;
+    a_uint32_t cnt = 0;
+    a_uint16_t rData = 0;
+
+    a_uint32_t FW_VER    = 0;
+    a_uint32_t MAIN_VER  = 0;
+    a_uint32_t SW_VER    = 0;
+    a_uint32_t TOP_VER   = 0;
+    a_uint32_t AFEFW_VER = 0;
+    rtk_phy_hwpatch_t *patch_fwpr_conf;
+    rtk_phy_hwpatch_t *patch_fwlm_conf;
+    rtk_phy_hwpatch_t *patch_afe_conf;
+    rtk_phy_hwpatch_t *patch_sds_conf;
+    rtk_phy_hwpatch_t *patch_top_conf;
+    a_uint32_t size_fwpr_conf = 0;
+    a_uint32_t size_fwlm_conf = 0;
+    a_uint32_t size_afe_conf  = 0;
+    a_uint32_t size_sds_conf  = 0;
+    a_uint32_t size_top_conf  = 0;
+
+    rData = phy_common_general_reg_mmd_get(unit, port, 30, 0x104);
+		
+	
+
+	FW_VER    = RTL8261N_C_FW_VER;
+	MAIN_VER  = RTL8261N_C_MAIN_VER;
+	SW_VER    = RTL8261N_C_SW_VER;
+	TOP_VER   = RTL8261N_C_TOP_VER;
+	AFEFW_VER = RTL8261N_C_AFEFW_VER;
+	patch_fwpr_conf = rtl8261N_C_patch_fwpr_conf;
+	patch_fwlm_conf = rtl8261N_C_patch_fwlm_conf;
+	patch_afe_conf  = rtl8261N_C_patch_afe_conf;
+	patch_sds_conf  = rtl8261N_C_patch_sds_conf;
+	patch_top_conf  = rtl8261N_C_patch_top_conf;
+	size_fwpr_conf = sizeof(rtl8261N_C_patch_fwpr_conf);
+	size_fwlm_conf = sizeof(rtl8261N_C_patch_fwlm_conf);
+	size_afe_conf  = sizeof(rtl8261N_C_patch_afe_conf);
+	size_sds_conf  = sizeof(rtl8261N_C_patch_sds_conf);
+	size_top_conf  = sizeof(rtl8261N_C_patch_top_conf);
+	
+	
+    //PP_TOPReg w $PHYID 90 18 ,(0x2d2)
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_TOP, 0xff, 90, 18, 15, 0, MAIN_VER)) != RT_ERR_OK)
+        return ret;
+    //PP_TOPReg w $PHYID 90 19 ,(0x2d3)
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_TOP, 0xff, 90, 19, 15, 0, SW_VER)) != RT_ERR_OK)
+        return ret;
+    //PP_TOPReg w $PHYID 90 20 ,(0x2d4)
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_TOP, 0xff, 90, 21, 15, 0, TOP_VER)) != RT_ERR_OK)
+        return ret;
+    //PP_TOPReg w $PHYID 90 21 ,(0x2d5)
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_TOP, 0xff, 90, 21, 15, 0, AFEFW_VER)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg w $PHYID 0xB820 0x0010
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xb820, 15, 0, 0x0010)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg_bit r $PHYID 0xB800 6 6 wait 1
+    if ((ret = _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND2, 0xB800, RTLBIT_6, RTLBIT_6, bcast)) != RT_ERR_OK)
+        return ret;
+
+    if ((ret = _phy_rtl826xb_patch_process(unit, port, portOffset, patch_fwpr_conf, size_fwpr_conf, &cnt, bcast))!= RT_ERR_OK)
+    {
+        
+        return ret;
+    }
+   
+
+    //PP_PHYReg w $PHYID 0xB820 0x0000
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xb820, 15, 0, 0x0000)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg_bit r $PHYID 0xB800 6 6  wait 0
+    if ((ret = _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND2, 0xB800, 0, RTLBIT_6, bcast)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg_bit w $::broadcast_PHYID 0xA4a0 10 10 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xA4A0, 10, 10, 0x1)) != RT_ERR_OK)
+        return ret;
+
+    //[PP_PHYReg_bit r $PHYID 0xa600 7 0]
+    if ((ret = _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND2, 0xa600, 0x1, 0xFF, bcast)) != RT_ERR_OK)
+        return ret;
+
+    if ((ret = _phy_rtl826xb_patch_process(unit, port, portOffset, patch_fwlm_conf, size_fwlm_conf, &cnt, bcast))!= RT_ERR_OK)
+    {
+       
+        return ret;
+    }
+   
+
+    //xg_patch_en_flag
+    //PP_PHYReg_bit w $PHYID 0xbf86 9 9 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 9, 9, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 8 8 0x0
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 8, 8, 0x0)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 7 7 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 7, 7, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 6 6 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 6, 6, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 5 5 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 5, 5, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 4 4 0x1;
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 4, 4, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 6 6 0x0
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 6, 6, 0x0)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 9 9 0x0
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 9, 9, 0x0)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 7 7 0x0
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 7, 7, 0x0)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg_bit r $PHYID 0xbc62 12 8
+     rData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xbc62);
+     
+    rData = REG32_FIELD_GET(rData, 8, 0x1F00);
+    for (cnt = 0; cnt <= rData; cnt++)
+    {
+        //PP_PHYReg_bit w $PHYID 0xbc62 12 8 $t
+        if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbc62, 12, 8, cnt)) != RT_ERR_OK)
+        return ret;
+    }
+
+    //PP_PHYReg_bit w $PHYID 0xbc02 2 2 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbc02, 2, 2, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbc02 3 3 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbc02, 3, 3, 0x1)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg_bit w $PHYID 0xbf86 6 6 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 6, 6, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 9 9 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 9, 9, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbf86 7 7 0x1
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbf86, 7, 7, 0x1)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg_bit w $PHYID 0xbc04 9 2 0xff
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xbc04, 9, 2, 0xff)) != RT_ERR_OK)
+        return ret;
+
+
+    //PP_PHYReg w $::broadcast_PHYID 0xA4a0 0x0180
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xA4A0, 15, 0, 0x0180)) != RT_ERR_OK)
+        return ret;
+
+    //[PP_PHYReg_bit r $PHYID 0xa600 7 0]
+    if ((ret = _phy_rtl826xb_patch_wait_not_equal(unit, port, PHY_MMD_VEND2, 0xa600, 0x1, 0xFF, bcast)) != RT_ERR_OK)
+        return ret;
+
+    //PP_PHYReg w $::broadcast_PHYID 0xA436 0x801E
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xA436, 15, 0, 0x801E)) != RT_ERR_OK)
+        return ret;
+    //PP_PHYReg w $::broadcast_PHYID 0xA438 $currentVersion
+    if ((ret = phy_rtl826xb_patch_op(unit, port, portOffset, RTK_HWPATCH_OP_PHY, 0xff, 0x00, 0xA438, 15, 0, FW_VER)) != RT_ERR_OK)
+        return ret;
+
+    if ((ret = _phy_rtl826xb_patch_process(unit, port, portOffset, patch_afe_conf, size_afe_conf, &cnt, bcast)) != RT_ERR_OK)
+    {
+        
+        return ret;
+    }
+  
+
+    if ((ret = _phy_rtl826xb_patch_process(unit, port, portOffset, patch_top_conf, size_top_conf, &cnt, bcast))!= RT_ERR_OK)
+    {
+       
+        return ret;
+    }
+    
+
+    if ((ret = _phy_rtl826xb_patch_process(unit, port, portOffset, patch_sds_conf, size_sds_conf, &cnt, bcast))!= RT_ERR_OK)
+    {
+       
+        return ret;
+    }
+ 
+
+    return ret;
+}
+
+/* Function Name:
+ *      phy_rtl826xb_broadcast_patch
+ * Description:
+ *      apply patch data to PHY
+ * Input:
+ *      unit       - unit id
+ *      baseport   - base port id on the PHY chip
+ *      portOffset - the index offset base on baseport for the port to patch
+ *      perChip    - 1 for per-chip mode, 0 for per-bus mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_SUPPORTED
+ *      RT_ERR_ABORT
+ * Note:
+ *      None
+ */
+a_int32_t phy_rtl826xb_broadcast_patch(a_uint32_t unit, a_uint32_t port, a_uint8_t portOffset)
+{
+    return _phy_rtl826xb_patch(unit, port, portOffset, PHY_PATCH_OP_BCAST);
+}
\ No newline at end of file
diff --git a/src/hsl/phy/rtl.c b/src/hsl/phy/rtl.c
new file mode 100644
index 00000000..d4191518
--- /dev/null
+++ b/src/hsl/phy/rtl.c
@@ -0,0 +1,520 @@
+/*
+ * Copyright (c) 2018-2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "phy_common.h"
+#include "phy_rtl826xb.h"
+#include "fal_port_ctrl.h"
+#include <linux/phy.h>
+#include <linux/mdio.h>
+
+
+
+#define RTL_PHY_LINK_UP         1
+#define RTL_PHY_LINK_DOWN       0
+
+LIST_HEAD(g_rtl_phy_list);
+struct rtl_phy_info* rtl_phy_info_get(a_uint32_t phy_addr)
+{
+	struct rtl_phy_info *pdata = NULL;
+	list_for_each_entry(pdata, &g_rtl_phy_list, list) {
+		if (pdata->phydev_addr == phy_addr) {
+			return pdata;
+		}
+	}
+
+	SSDK_ERROR("%s can't get the data for phy addr: %d\n", __func__, phy_addr);
+	return NULL;
+}
+
+static a_bool_t rtl_config_init_done = A_FALSE;
+static int rtl_config_init(struct phy_device *phydev)
+{
+	a_uint32_t dev_id = 0, phy_id = 0;
+	a_uint16_t phyData;
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+	
+	linkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_AUI_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_BNC_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, mask);
+	
+	linkmode_copy(phydev->supported, mask);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
+
+	if(linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->advertising))
+		linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, mask);
+	if(linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->advertising))
+		linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, mask);
+	linkmode_copy(phydev->advertising, mask);
+	
+	//close the 10G autoneg ability
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_AN, 32);
+        phyData &= (~(0x0080 | 0x0100 | 0x1000));
+        phyData |= 0x0080;
+        phyData |= 0x0100;
+        phy_common_general_reg_mmd_set(dev_id, phy_id, PHY_MMD_AN, 32, phyData);
+
+//	phy_826xb_init(dev_id, phy_id);
+	
+	return 0;
+}
+
+sw_error_t
+_phy_826x_interrupt_mask_get(a_uint32_t unit, a_uint32_t port, a_uint32_t *pEnaBitmap)
+{
+    sw_error_t   ret = RT_ERR_OK;
+    a_uint16_t  phyData = 0;
+    a_uint32_t  bitmap = 0;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0xE1);
+
+
+    if (phyData & 0x0001)
+        bitmap |= RTK_PHY_CTRL_INTR_MASK_COMMON;
+    if (phyData & 0x0002)
+        bitmap |= RTK_PHY_CTRL_INTR_MASK_RLFD;
+    if (phyData & 0x0008)
+        bitmap |= RTK_PHY_CTRL_INTR_MASK_TM_LOW;
+    if (phyData & 0x0010)
+        bitmap |= RTK_PHY_CTRL_INTR_MASK_TM_HIGH;
+    *pEnaBitmap = bitmap;
+    return ret;
+}
+
+
+sw_error_t
+_phy_826xb_interrupt_mask_get(a_uint32_t unit, a_uint32_t port, a_uint16_t *pMask)
+{
+    sw_error_t ret = 0;
+    a_uint32_t bitmap = 0;
+
+    _phy_826x_interrupt_mask_get(unit, port, &bitmap);
+
+    *pMask = (bitmap & (1 << 0)) ? (1) : (0);
+    return ret;
+}
+
+sw_error_t
+_phy_826xb_interrupt_mask_set(a_uint32_t unit, a_uint32_t port, a_uint32_t enaBitmap)
+{
+    sw_error_t   ret = RT_ERR_OK;
+    a_uint16_t  phyData = 0, currentData = 0;
+
+    currentData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0xE1);
+       
+    phyData = currentData;
+    phyData &= (~(0x0001 | 0x0002 | 0x0008 | 0x0010));
+    if (enaBitmap & RTK_PHY_CTRL_INTR_MASK_COMMON)
+        phyData |= 0x0001;
+    if (enaBitmap & RTK_PHY_CTRL_INTR_MASK_RLFD)
+        phyData |= 0x0002;
+    if (enaBitmap & RTK_PHY_CTRL_INTR_MASK_TM_LOW)
+        phyData |= 0x0008;
+    if (enaBitmap & RTK_PHY_CTRL_INTR_MASK_TM_HIGH)
+        phyData |= 0x0010;
+
+    if (currentData != phyData)
+    {
+        ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE1, phyData);
+        return ret;
+    }
+    return ret;
+}
+
+a_uint32_t
+phy_826xb_intrMask_set(a_uint32_t unit, a_uint32_t port, rtk_phy_intr_t phyIntr, a_uint32_t mask)
+{
+    a_uint32_t   ret = 0;
+    a_uint16_t  bitmap = 0;
+
+    if ((ret = _phy_826xb_interrupt_mask_get(unit, port, &bitmap)) != RT_ERR_OK)
+        return ret;
+
+    if (mask == 0)
+    {
+        bitmap &= (~(1 << phyIntr));
+    }
+    else
+    {
+        bitmap |= (1 << phyIntr);
+    }
+
+    if ((ret = _phy_826xb_interrupt_mask_set(unit, port, bitmap)) != RT_ERR_OK)
+        return ret;
+    return ret;
+}
+
+
+static int rtl_config_intr(struct phy_device *phydev)
+{
+	a_uint32_t dev_id = 0, phy_id = 0, bitmap = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+	
+	if (phydev->interrupts == RTK_PHY_INTR_COMMON)
+		_phy_826xb_interrupt_mask_set(dev_id, phy_id, bitmap |(1 << RTK_PHY_INTR_COMMON));	
+	else if (phydev->interrupts == RTK_PHY_INTR_RLFD)
+		_phy_826xb_interrupt_mask_set(dev_id, phy_id, bitmap &(~(1 << RTK_PHY_INTR_RLFD)));
+	else if (phydev->interrupts == RTK_PHY_INTR_TM_LOW)
+		_phy_826xb_interrupt_mask_set(dev_id, phy_id, bitmap &(~(1 << RTK_PHY_INTR_TM_LOW)));
+	else if (phydev->interrupts == RTK_PHY_INTR_TM_HIGH)
+		_phy_826xb_interrupt_mask_set(dev_id, phy_id, bitmap &(~(1 << RTK_PHY_INTR_TM_HIGH)));
+	else if (phydev->interrupts == RTK_PHY_INTR_END)
+		_phy_826xb_interrupt_mask_set(dev_id, phy_id, bitmap &(~(1 << RTK_PHY_INTR_END)));
+	return 0;
+	
+}
+
+static int rtl_ack_interrupt(struct phy_device *phydev)
+{
+	return 0;
+
+}
+
+static a_uint32_t rtl_negtiation_cap_get(struct phy_device *phydev)
+{
+	a_uint32_t autoneg = 0;
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising) = { 0, };
+	linkmode_and(advertising, phydev->advertising, phydev->supported);
+	
+if (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_PAUSE;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_ASY_PAUSE;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_10T_HD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_10T_FD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_100TX_HD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_100TX_FD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_1000T_FD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_2500T_FD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_5000T_FD;
+	}
+	if (linkmode_test_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, advertising)) {
+		autoneg |= FAL_PHY_ADV_10000T_FD;
+	}
+	return autoneg;
+}
+
+static int rtl_config_aneg(struct phy_device *phydev)
+{	
+	a_uint16_t phy_data = 0;
+	a_uint32_t dev_id = 0, phy_id = 0;
+	a_uint32_t advertise = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+	if (!pdata) {
+		return SW_FAIL;
+	}
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+	if (phydev->autoneg != AUTONEG_ENABLE)
+	{
+		/* force speed */
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+		phy_data = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_AN, 0);
+		phy_data &= ~(0x1000);
+		
+		phy_826xb_duplex_set(dev_id, phy_id, phydev->duplex);
+		phy_826xb_speed_set(dev_id, phy_id, phydev->speed);
+	} else {
+	advertise = rtl_negtiation_cap_get(phydev);
+	/*link would be down if there is no speed adv except for pause*/
+	if(!(advertise & ~(FAL_PHY_ADV_PAUSE | FAL_PHY_ADV_ASY_PAUSE))) {
+		return SW_BAD_VALUE;
+	}
+	
+	phy_826xb_autoNegoAbility_set(dev_id, phy_id, advertise);
+	phy_826xb_restart_autoneg(dev_id, phy_id);
+//	phy_826xb_autoNegoEnable_set(dev_id, phy_id);
+	}
+	return 0;
+}
+
+static int rtl_aneg_done(struct phy_device *phydev)
+{
+	a_uint16_t phy_data;
+	a_uint32_t dev_id = 0, phy_id = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+
+	if (!pdata) {
+		return SW_FAIL;
+	}
+
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+	
+	phy_data = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_AN, 0x01);
+
+
+	return (phy_data < 0) ? phy_data : (phy_data & (1<<5));
+}
+
+static int rtl_read_status(struct phy_device *phydev)
+{
+	struct port_phy_status phy_status;
+	a_uint32_t dev_id = 0, phy_id = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+
+	if(!rtl_config_init_done)
+	{
+		if(!rtl_config_init(phydev))
+		{
+			rtl_config_init_done = A_TRUE;
+		}
+	}
+
+	if (!pdata) {
+		return SW_FAIL;
+	}
+
+
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+		
+	rtl826x_phy_get_status(dev_id, phy_id, &phy_status);
+
+	if (phy_status.link_status) {
+		phydev->link = RTL_PHY_LINK_UP;
+	} else {
+		phydev->link = RTL_PHY_LINK_DOWN;
+	}
+
+	switch (phy_status.speed) {
+		case FAL_SPEED_10000:
+			phydev->speed = SPEED_10000;
+			break;
+		case FAL_SPEED_5000:
+			phydev->speed = SPEED_5000;
+			break;
+		case FAL_SPEED_2500:
+			phydev->speed = SPEED_2500;
+			break;
+		case FAL_SPEED_1000:
+			phydev->speed = SPEED_1000;
+			break;
+		case FAL_SPEED_100:
+			phydev->speed = SPEED_100;
+			break;
+		default:
+			phydev->speed = SPEED_10;
+			break;
+	}
+
+	if (phy_status.duplex == FAL_FULL_DUPLEX) {
+		phydev->duplex = DUPLEX_FULL;
+	} else {
+		phydev->duplex = DUPLEX_HALF;
+	}
+	return 0;
+}
+
+static int rtl_suspend(struct phy_device *phydev)
+{
+	a_uint32_t dev_id = 0, phy_id = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+
+	if (!pdata) {
+		return SW_FAIL;
+	}
+
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+
+	return phy_826xb_poweroff(dev_id, phy_id);
+}
+
+
+static int rtl_resume(struct phy_device *phydev)
+{
+	a_uint32_t dev_id = 0, phy_id = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+
+	if (!pdata) {
+		return SW_FAIL;
+	}
+
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+
+	return phy_826xb_poweron(dev_id, phy_id);
+}
+
+static a_bool_t rtl_sfp_present(struct phy_device *phydev)
+{
+	rtl_priv *priv = phydev->priv;
+	struct rtl_phy_info *pdata = priv->phy_info;
+	a_uint32_t phy_id = 0;
+	sw_error_t rv = SW_OK;
+
+	if (!pdata) {
+		SSDK_ERROR("pdata is null\n");
+		return A_FALSE;
+	}
+	rv = phy_826xb_phy_id_get(pdata->dev_id, pdata->phy_addr, &phy_id);
+	if(rv == SW_READ_ERROR) {
+		return A_FALSE;
+	}
+
+	return A_TRUE;
+}
+
+
+static int rtl_soft_reset(struct phy_device *phydev)
+{
+	a_uint32_t dev_id = 0, phy_id = 0;
+	rtl_priv *priv = phydev->priv;
+	const struct rtl_phy_info *pdata = priv->phy_info;
+
+	if(!rtl_sfp_present(phydev)) {
+		return 0;
+	}
+
+	if (!pdata) {
+		return SW_FAIL;
+	}
+
+	dev_id = pdata->dev_id;
+	phy_id = pdata->phy_addr;
+
+	return phy_common_c45_reset_set(dev_id, phy_id);
+}
+
+static void rtl_link_change_notify(struct phy_device *phydev)
+{
+
+	
+}
+
+
+
+static int rtl_phy_probe(struct phy_device *phydev)
+{
+	rtl_priv *priv;
+	int err = 0;
+
+	priv = kzalloc(sizeof(rtl_priv), GFP_KERNEL);
+	if (!priv) {
+		return -ENOMEM;
+	}
+
+	priv->phydev = phydev;
+	priv->phy_info = rtl_phy_info_get(phydev->mdio.addr);
+
+	phydev->priv = priv;
+
+	return err;
+}
+
+static void rtl_phy_remove(struct phy_device *phydev)
+{
+	rtl_priv *priv = phydev->priv;
+	kfree(priv);
+}
+
+struct phy_driver rtl_phy_driver = {
+	.phy_id		= RTL_PHY,
+	.phy_id_mask    = 0xffffffff,
+	.name		= "rtl ethernet",
+	.features	= PHY_GBIT_FEATURES,
+
+	.probe		= rtl_phy_probe,
+	.remove		= rtl_phy_remove,
+	.config_init	= rtl_config_init,
+	.config_intr	= rtl_config_intr,
+	.config_aneg	= rtl_config_aneg,
+	.aneg_done	= rtl_aneg_done,
+	.ack_interrupt	= rtl_ack_interrupt,
+	.read_status	= rtl_read_status,
+	.suspend	= rtl_suspend,
+	.resume		= rtl_resume,
+	.soft_reset	= rtl_soft_reset,
+	.link_change_notify     = rtl_link_change_notify,
+	.mdiodrv.driver		= { .owner = THIS_MODULE },
+};
+
+a_uint32_t rtl_phy_driver_register(void)
+{
+	a_int32_t ret;
+	ret = phy_driver_register(&rtl_phy_driver, THIS_MODULE);
+	return ret;
+}
+
+void rtl_phy_driver_unregister(void)
+{
+	phy_driver_unregister(&rtl_phy_driver);
+}
+
+void rtl_phydev_init(a_uint32_t dev_id, a_uint32_t port_id)
+{
+	struct rtl_phy_info *pdata;
+	pdata = kzalloc(sizeof(struct rtl_phy_info), GFP_KERNEL);
+
+	if (!pdata) {
+		return;
+	}
+	list_add_tail(&pdata->list, &g_rtl_phy_list);
+	pdata->dev_id = dev_id;
+	/* the phy address may be the i2c slave addr or mdio addr */
+	pdata->phy_addr = qca_ssdk_port_to_phy_addr(dev_id, port_id);
+	pdata->phydev_addr = pdata->phy_addr;
+}
+
+void rtl_phydev_deinit(a_uint32_t dev_id, a_uint32_t port_id)
+{
+	struct rtl_phy_info *pdata, *pnext;
+
+
+	list_for_each_entry_safe(pdata, pnext, &g_rtl_phy_list, list) {
+		list_del(&pdata->list);
+		kfree(pdata);
+	}
+}
diff --git a/src/hsl/phy/rtl826xb_phy.c b/src/hsl/phy/rtl826xb_phy.c
new file mode 100644
index 00000000..cd658e63
--- /dev/null
+++ b/src/hsl/phy/rtl826xb_phy.c
@@ -0,0 +1,1521 @@
+#include "sw.h"
+#include "fal_port_ctrl.h"
+#include "hsl_api.h"
+#include "hsl.h"
+#include "phy_common.h"
+#include "phy_rtl826xb.h"
+#include "hsl_phy.h"
+#include "ssdk_plat.h"
+
+static a_bool_t phy_ops_flag = 0;
+static a_bool_t phy_dev_drv_init_flag = 0;
+
+static struct mutex rtl_reg_lock;
+
+#define RTL_LOCKER_INIT		mutex_init(&rtl_reg_lock)
+#define RTL_REG_LOCK		mutex_lock(&rtl_reg_lock)
+#define RTL_REG_UNLOCK		mutex_unlock(&rtl_reg_lock)
+
+
+
+#define RTK_PHY_CTRL_RTCT_CABLE_TYPE_NONE       0
+#define RTK_PHY_CTRL_RTCT_CABLE_TYPE_CAT5E      1
+#define RTK_PHY_CTRL_RTCT_CABLE_TYPE_CAT6A      2
+#define RTK_PHY_CTRL_RTCT_CABLE_TYPE_CAT6A_UU   3  
+
+#define RTK_PHY_CTRL_SERDES_MODE_USXGMII                              0x0000  /* USXGMII */
+#define RTK_PHY_CTRL_SERDES_MODE_UNKNOWN                              0xFFFF
+
+
+
+phy_rtl826xb_info_t *rtl826xb_info[RTK_MAX_NUM_OF_UNIT] = { NULL };
+
+
+void rtl826xb_phy_lock_init(void)
+{
+	static a_bool_t is_init = A_FALSE;
+
+	if(!is_init)
+	{
+		RTL_LOCKER_INIT;
+		is_init = A_TRUE;
+	}
+
+	return;
+}
+
+
+
+static a_uint16_t rtl826x_phy_mmd_read(a_uint32_t dev_id, a_uint32_t phy_id, a_uint16_t reg_mmd, a_uint16_t reg_id)
+{
+	a_uint16_t phy_data;
+	sw_error_t rv;
+	a_uint32_t reg_id_c45 = RTL826XB_REG_ADDRESS(reg_mmd, reg_id);
+	HSL_PHY_GET(rv, dev_id, phy_id, reg_id_c45, &phy_data);
+
+	return phy_data;
+}
+
+
+static sw_error_t rtl826x_phy_mmd_write(a_uint32_t dev_id, a_uint32_t phy_id, a_uint16_t reg_mmd, a_uint16_t reg_id, a_uint16_t reg_val)
+{
+	sw_error_t rv;
+	a_uint32_t reg_id_c45 = RTL826XB_REG_ADDRESS(reg_mmd, reg_id);
+	HSL_PHY_SET(rv, dev_id,  phy_id, reg_id_c45, reg_val);
+
+	return rv;
+}
+
+
+static a_uint16_t rtl826x_phy_reg_read(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t reg)
+{
+	a_uint16_t phy_data;
+	sw_error_t rv;
+	HSL_PHY_GET(rv, dev_id, phy_id, reg, &phy_data);
+
+	return phy_data;
+}
+
+
+static sw_error_t rtl826x_phy_reg_write(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t reg, a_uint16_t reg_val)
+{
+	sw_error_t rv;
+	
+	HSL_PHY_SET(rv, dev_id,  phy_id, reg, reg_val);
+
+	return rv;
+}
+
+
+static a_int16_t hal_miim_mmd_read(a_uint32_t dev_id, a_uint32_t phy_id, a_uint16_t mmdAddr, a_uint16_t mmdReg)
+{
+	a_uint16_t phy_data;
+	sw_error_t rv;
+	
+	a_uint32_t reg_id_c45 = RTL826XB_REG_ADDRESS(mmdAddr, mmdReg);
+	
+	HSL_PHY_GET(rv, dev_id, phy_id, reg_id_c45, &phy_data);
+	
+	return phy_data;
+}
+
+
+
+static a_int32_t hal_miim_mmd_write(a_uint32_t dev_id, a_uint32_t phy_id, a_uint16_t mmdAddr, a_uint16_t mmdReg, a_uint16_t phy_data)
+{
+	sw_error_t rv;
+	
+	a_uint32_t reg_id_c45 = RTL826XB_REG_ADDRESS(mmdAddr, mmdReg);
+	
+	HSL_PHY_SET(rv, dev_id, phy_id, reg_id_c45, phy_data);
+	
+
+	return rv;
+}
+
+
+/* Function Name:
+ *      phy_common_general_reg_mmd_get
+ * Description:
+ *      Get PHY registers. Support access C45 reg by C22 format when connect to C22 MAC.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      mmdAddr - mmd device address
+ *      mmdReg  - mmd reg id
+ * Output:
+ *      pData   - pointer buffer of read data
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      None
+ */
+ 
+ a_uint16_t
+phy_common_general_reg_mmd_get(a_uint32_t unit, a_uint32_t port, a_uint16_t mmdAddr, a_uint16_t mmdReg)
+{
+	return hal_miim_mmd_read(unit, port, mmdAddr, mmdReg);
+}
+
+
+/* Function Name:
+ *      phy_common_general_reg_mmd_set
+ * Description:
+ *      Set PHY registers. Support access C45 reg by C22 format when connect to C22 MAC.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      mmdAddr - mmd device address
+ *      mmdReg  - mmd reg id
+ *      data    - write data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - OK
+ *      RT_ERR_FAILED - Failed
+ * Note:
+ *      None
+ */
+a_int32_t
+phy_common_general_reg_mmd_set(a_uint32_t unit, a_uint32_t port, a_uint16_t mmdAddr, a_uint16_t mmdReg, a_uint16_t data)
+{
+    /* temporary support C45 only */
+    return hal_miim_mmd_write(unit, port, mmdAddr, mmdReg, data);
+}
+
+
+sw_error_t phy_common_c45_speed_get(a_uint32_t unit, a_uint32_t port, fal_port_speed_t *pSpeed)
+{
+	struct port_phy_status phy_status = {0};
+	rtl826x_phy_get_status(unit,  port, &phy_status);
+	*pSpeed=phy_status.speed;
+	return SW_OK;
+}
+
+
+a_int32_t
+_phy_826xb_loopback_remote_set(a_uint32_t unit, a_uint32_t port, a_uint32_t ena)
+{
+    
+    a_uint16_t  phyData = 0;
+    fal_port_speed_t speed;
+
+    phy_common_c45_speed_get(unit, port, &speed);
+      
+
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xBCE8, 0x0040);
+            
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC800, 0x5A02);
+            
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC416, 0x0550);
+              
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC464, 0x0001);
+              
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC45E, 0x2C84);
+             
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC45C, 0xAC61);
+     
+
+    if (ena != 0)
+    {
+        switch (speed)
+        {
+            case FAL_SPEED_100:
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xBCE8);
+                    
+                phyData |= REG32_FIELD_SET(phyData, 1, 13, 0x2000);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xBCE8, phyData);
+                   
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC800);
+                    
+                phyData = REG32_FIELD_SET(phyData, 1, 4, 0x0030);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC800, phyData);
+                   
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC416);
+                    
+                phyData = REG32_FIELD_SET(phyData, 3, 2, 0x000C);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC416, phyData);
+                    
+                break;
+
+            case FAL_SPEED_1000:
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC800);
+                    
+                phyData = REG32_FIELD_SET(phyData, 1, 4, 0x0030);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC800, phyData);
+                  
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC416);
+                    
+                phyData = REG32_FIELD_SET(phyData, 3, 2, 0x000C);
+               phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC416, phyData);
+                   
+                break;
+
+            default:
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC464);
+                  
+                phyData &= (~RTLBIT_0);
+               phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC464, phyData);
+                   
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC464);
+                   
+                phyData |= (RTLBIT_1);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC464, phyData);
+                    
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC464);
+                    
+                phyData |= (RTLBIT_0);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC464, phyData);
+                   
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC45E);
+                   
+                phyData |= (RTLBIT_15);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC45E, phyData);
+                  
+                phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC45C);
+                 
+                 phyData &= (~RTLBIT_13);
+                phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC45C, phyData);
+                 
+                break;
+        }
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x2A1);
+          
+        phyData |= (RTLBIT_10);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x2A1, phyData);
+         
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x291);
+            
+        phyData |= (RTLBIT_5);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x291, phyData);
+       
+    }
+    else
+    {
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x2A1);
+           
+        phyData &= (~RTLBIT_10);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x2A1, phyData);
+           
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x291);
+         
+        phyData &= (~RTLBIT_5);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x291, phyData);
+         
+    }
+    return SW_OK;
+}
+
+
+
+a_int32_t
+phy_826xb_broadcastEnable_set(a_uint32_t unit, a_uint32_t port, rtk_enable_t enable)
+{
+   
+    a_uint16_t  phyData = 0;
+
+    if (enable == DISABLED)
+    {
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x9003, 0);
+       
+    }
+    else
+    {
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x9003);
+        
+        phyData |= (RTLBIT_15);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x9003, phyData);
+          
+    }
+
+    return SW_OK;
+}
+
+
+a_int32_t
+phy_826xb_broadcastID_set(a_uint32_t unit, a_uint32_t port, a_uint32_t broadcastID)
+{
+    a_uint16_t  phyData = 0;
+
+    if (broadcastID > 0x1F)
+        return SW_OUT_OF_RANGE;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x9003);
+      
+    phyData = REG32_FIELD_SET(phyData, broadcastID, 0, 0x1F);
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x9003, phyData);
+     
+    return SW_OK;
+}
+
+a_int32_t
+_phy_826xb_rtct_cable_set(a_uint32_t unit, a_uint32_t port, a_uint32_t cableType)
+{
+    a_int32_t   ret = RT_ERR_OK;
+
+    rtl826xb_info[unit]->rtctCable[port] = cableType;
+    return ret;
+}
+
+/* Function Name:
+ *      phy_826xb_ctrl_set
+ * Description:
+ *      Set PHY settings for specific feature
+ * Input:
+ *      unit      - unit id
+ *      port      - port id
+ *      ctrl_type - setting type
+ *      value     - setting value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_SUPPORTED
+ * Note:
+ *      None
+ */
+sw_error_t
+phy_826xb_ctrl_set(a_uint32_t unit, a_uint32_t port, rtk_phy_ctrl_t ctrl_type, a_uint16_t value)
+{
+ //   a_int32_t   ret = 0;
+    a_uint16_t  phyData = 0;
+ //   a_uint32_t  tmp = 0;
+
+    switch (ctrl_type)
+    {
+/*        case RTK_PHY_CTRL_LED_1_MODE:
+        case RTK_PHY_CTRL_LED_2_MODE:
+        case RTK_PHY_CTRL_LED_3_MODE:
+        case RTK_PHY_CTRL_LED_4_MODE:
+        case RTK_PHY_CTRL_LED_5_MODE:
+        case RTK_PHY_CTRL_LED_6_MODE:
+            ret = _phy_826xb_led_mode_set(unit, port, (ctrl_type - RTK_PHY_CTRL_LED_1_MODE), value);
+            break;
+        case RTK_PHY_CTRL_LED_CFG_FLASH_RATE:
+            ret = _phy_826xb_led_config_flash_rate_set(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_LED_CFG_BLINK_RATE:
+            ret = _phy_826xb_led_config_blink_rate_set(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_LED_1_CFG_ACTIVE_LOW:
+        case RTK_PHY_CTRL_LED_2_CFG_ACTIVE_LOW:
+        case RTK_PHY_CTRL_LED_3_CFG_ACTIVE_LOW:
+        case RTK_PHY_CTRL_LED_4_CFG_ACTIVE_LOW:
+        case RTK_PHY_CTRL_LED_5_CFG_ACTIVE_LOW:
+        case RTK_PHY_CTRL_LED_6_CFG_ACTIVE_LOW:
+            ret = _phy_826xb_led_config_active_low_set(unit, port, (ctrl_type - RTK_PHY_CTRL_LED_1_CFG_ACTIVE_LOW), value);
+            break;
+        case RTK_PHY_CTRL_LED_1_CFG_FORCE:
+        case RTK_PHY_CTRL_LED_2_CFG_FORCE:
+        case RTK_PHY_CTRL_LED_3_CFG_FORCE:
+        case RTK_PHY_CTRL_LED_4_CFG_FORCE:
+        case RTK_PHY_CTRL_LED_5_CFG_FORCE:
+        case RTK_PHY_CTRL_LED_6_CFG_FORCE:
+            ret = _phy_826xb_led_config_force_set(unit, port, (ctrl_type - RTK_PHY_CTRL_LED_1_CFG_FORCE), value);
+            break;
+
+        case RTK_PHY_CTRL_LOOPBACK_INTERNAL_PMA:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_PMAPMD, 0, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~RTLBIT_0);
+            phyData |= (value == 0)? (0):(RTLBIT_0);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_PMAPMD, 0, phyData)) != RT_ERR_OK)
+                return ret;
+            break;*/
+
+        case RTK_PHY_CTRL_LOOPBACK_REMOTE:
+            _phy_826xb_loopback_remote_set(unit, port, value);
+            break;
+
+        case RTK_PHY_CTRL_RAPID_LINK_FAULT_DETECT:
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA442);
+               
+            phyData &= (~RTLBIT_15);
+            phyData |= (value == 0)? (0):(RTLBIT_15);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA442, phyData);
+             
+            break;
+
+   /*     case RTK_PHY_CTRL_MDI_INVERSE:
+            RT_LOG(LOG_DEBUG, (MOD_DAL|MOD_PHY), "u %u,p %u,RTK_PHY_CTRL_MDI_INVERSE=0x%X ", unit, port, value);
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x100, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~RTLBIT_10);
+            phyData |= (value == 0)? (0):(RTLBIT_10);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x100, phyData)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_MDI_POLARITY_SWAP:
+            RT_LOG(LOG_DEBUG, (MOD_DAL|MOD_PHY), "u %u,p %u,RTK_PHY_CTRL_MDI_POLARITY_SWAP=0x%X ", unit, port, value);
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x31, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~(RTLBIT_0 | RTLBIT_1 | RTLBIT_2 | RTLBIT_3));
+            phyData |= (value & RTK_PHY_CTRL_MDI_POLARITY_SWAP_CH_A)? (RTLBIT_0) : (0);
+            phyData |= (value & RTK_PHY_CTRL_MDI_POLARITY_SWAP_CH_B)? (RTLBIT_1) : (0);
+            phyData |= (value & RTK_PHY_CTRL_MDI_POLARITY_SWAP_CH_C)? (RTLBIT_2) : (0);
+            phyData |= (value & RTK_PHY_CTRL_MDI_POLARITY_SWAP_CH_D)? (RTLBIT_3) : (0);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x31, phyData)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PREAMBLE_RECOVERY:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x71, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~RTLBIT_12);
+            phyData |= (value == 0)? (0):(RTLBIT_12);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x71, phyData)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_SYNCE:
+            ret = _phy_826xb_synce_enable_set(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_SYNCE_PLL:
+            ret = _phy_826xb_synce_pll_set(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_SYNCE_0_CLOCK_FREQ:
+        case RTK_PHY_CTRL_SYNCE_1_CLOCK_FREQ:
+            ret = _phy_826xb_synce_clock_freq_set(unit, port, (ctrl_type - RTK_PHY_CTRL_SYNCE_CLOCK_FREQ), value);
+            break;
+        case RTK_PHY_CTRL_SYNCE_0_RECOVERY_PHY:
+        case RTK_PHY_CTRL_SYNCE_1_RECOVERY_PHY:
+            ret = _phy_826xb_synce_recovery_phy_set(unit, port, (ctrl_type - RTK_PHY_CTRL_SYNCE_RECOVERY_PHY), value);
+            break;
+        case RTK_PHY_CTRL_SYNCE_0_IDLE_MODE:
+        case RTK_PHY_CTRL_SYNCE_1_IDLE_MODE:
+            ret = _phy_826xb_synce_idle_mode_set(unit, port, (ctrl_type - RTK_PHY_CTRL_SYNCE_IDLE_MODE), value);
+            break;
+
+        case RTK_PHY_CTRL_NBASET_802P3BZ_MASK:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA5E8, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~(RTLBIT_13 | RTLBIT_14));
+            phyData |= (value == 0)? (0):(RTLBIT_13 | RTLBIT_14);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA5E8, phyData)) != RT_ERR_OK)
+                return ret;
+            ret = _phy_826xb_an_restart(unit, port);
+            break;
+        case RTK_PHY_CTRL_NBASET:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA5EA, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~(RTLBIT_15));
+            phyData |= (value == 0)? (RTLBIT_15):(0);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA5EA, phyData)) != RT_ERR_OK)
+                return ret;
+            ret = _phy_826xb_an_restart(unit, port);
+            break;
+
+        case RTK_PHY_CTRL_TEMP_THRESHOLD_HIGH_LOWER:
+        case RTK_PHY_CTRL_TEMP_THRESHOLD_HIGH_HIGHER:
+        case RTK_PHY_CTRL_TEMP_THRESHOLD_LOW_LOWER:
+        case RTK_PHY_CTRL_TEMP_THRESHOLD_LOW_HIGHER:
+            ret = _phy_826xb_temperature_threshold_set(unit, port, ctrl_type, value);
+            break;
+
+        case RTK_PHY_CTRL_FAST_RETRAIN_NFR:
+            switch (value)
+            {
+                case RTK_PHY_CTRL_FAST_RETRAIN_NFR_ENABLE:
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA5EA, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData &= (~RTLBIT_14);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA5EA, phyData)) != RT_ERR_OK)
+                        return ret;
+
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA654, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData |= (RTLBIT_11);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA654, phyData)) != RT_ERR_OK)
+                        return ret;
+                    break;
+
+                case RTK_PHY_CTRL_FAST_RETRAIN_NFR_DISABLE:
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA5EA, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData |= (RTLBIT_14);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA5EA, phyData)) != RT_ERR_OK)
+                        return ret;
+
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA654, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData &= (~RTLBIT_11);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA654, phyData)) != RT_ERR_OK)
+                        return ret;
+                    break;
+
+                default:
+                    return RT_ERR_INPUT;
+            }
+            ret = _phy_826xb_an_restart(unit, port);
+            break;
+
+        case RTK_PHY_CTRL_FAST_RETRAIN:
+            switch (value)
+            {
+                case RTK_PHY_CTRL_FAST_RETRAIN_ENABLE:
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 32, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData |= (RTLBIT_6 | RTLBIT_5 | RTLBIT_1);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_AN, 32, phyData)) != RT_ERR_OK)
+                        return ret;
+
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA6D8, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData |= (RTLBIT_7 | RTLBIT_1 | RTLBIT_0);
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA6D8, phyData)) != RT_ERR_OK)
+                        return ret;
+                    break;
+
+                case RTK_PHY_CTRL_FAST_RETRAIN_DISABLE:
+
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 32, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData &= (~(RTLBIT_6 | RTLBIT_5 | RTLBIT_1));
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_AN, 32, phyData)) != RT_ERR_OK)
+                        return ret;
+
+                    if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA6D8, &phyData)) != RT_ERR_OK)
+                        return ret;
+                    phyData &= (~(RTLBIT_7 | RTLBIT_1 | RTLBIT_0));
+                    if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA6D8, phyData)) != RT_ERR_OK)
+                        return ret;
+                    break;
+
+                default:
+                    return RT_ERR_INPUT;
+            }
+            ret = _phy_826xb_an_restart(unit, port);
+            break;*/
+
+        case RTK_PHY_CTRL_COUNTER_CLEAR:
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xC802);
+               
+            phyData &= (~(0xFF));
+            phyData |= (0x73);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC802, phyData);
+                
+
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1EF);
+               
+            phyData |= (RTLBIT_13 | RTLBIT_14 | RTLBIT_15);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1EF, phyData);
+                
+
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1EF);
+                
+            phyData &= (~(RTLBIT_13 | RTLBIT_14 | RTLBIT_15));
+
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1EF, phyData);
+               
+
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x230);
+                
+            phyData |= (RTLBIT_6 | RTLBIT_7 | RTLBIT_8);
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x230, phyData);
+               
+
+            phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x230);
+               
+            phyData &= (~(RTLBIT_6 | RTLBIT_7 | RTLBIT_8));
+            phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x230, phyData);
+                
+            break;
+
+    /*    case RTK_PHY_CTRL_SERDES_MODE:
+            ret = _phy_826xb_serdes_mode_set(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_SERDES_UPDTAE:
+            ret = _phy_826xb_serdes_mode_update(unit, port);
+            break;
+        case RTK_PHY_CTRL_SERDES_USXGMII_AN:
+            if ((ret = _phy_826xb_serdes_reg_read(unit, port, 7, 17, &phyData)) != RT_ERR_OK)
+                return ret;
+            tmp = (phyData & RTLBIT_0) ? (1) : (0);
+            if (tmp != value)
+            {
+                phyData &= (~RTLBIT_0);
+                phyData |= (value == 0) ? (0) : (RTLBIT_0);
+                if ((ret = _phy_826xb_serdes_reg_write(unit, port, 7, 17, phyData)) != RT_ERR_OK)
+                    return ret;
+            }
+            break;
+        case RTK_PHY_CTRL_SERDES_SGMII_AN:
+            if ((ret = _phy_826xb_serdes_reg_read(unit, port, 0, 2, &phyData)) != RT_ERR_OK)
+                return ret;
+            tmp = (phyData & RTLBIT_8) ? (0) : (1);
+            if (tmp != value)
+            {
+                phyData &= (~(RTLBIT_8 | RTLBIT_9));
+                phyData |= (value == 0) ? (RTLBIT_8) : (0);
+                if ((ret = _phy_826xb_serdes_reg_write(unit, port, 0, 2, phyData)) != RT_ERR_OK)
+                    return ret;
+            }
+            break;
+        case RTK_PHY_CTRL_SERDES_BASEX_AN:
+            if ((ret = _phy_826xb_serdes_reg_read(unit, port, 2, 0, &phyData)) != RT_ERR_OK)
+                return ret;
+            tmp = (phyData & RTLBIT_12) ? (1) : (0);
+            if (tmp != value)
+            {
+                phyData &= (~RTLBIT_12);
+                phyData |= (value == 0) ? (0) : (RTLBIT_12);
+                if ((ret = _phy_826xb_serdes_reg_write(unit, port, 2, 0, phyData)) != RT_ERR_OK)
+                    return ret;
+            }
+            break;
+
+        case RTK_PHY_CTRL_SNR_THRESHOLD_10G_MASTER:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x8188)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_10G_SLAVE:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x8152)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_5G_MASTER:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x811C)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_5G_SLAVE:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x80E6)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_2P5G_MASTER:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x80B0)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_2P5G_SLAVE:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87C, 0x807A)) != RT_ERR_OK)
+                return ret;
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xB87E, value)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SNR_THRESHOLD_1G:
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA804, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_DEBUG_DUMP_DSP:
+            ret = _phy_826xb_debug_dump_dsp(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_DEBUG_DUMP_DSP_INIT:
+            ret = _phy_826xb_debug_dump_dsp_init(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_DEBUG_DUMP_COUPLING:
+            ret = _phy_826xb_debug_coupling_dump(unit, port, value);
+            break;
+        case RTK_PHY_CTRL_REINIT:
+            ret = _phy_826xb_reinit(unit, port);
+            break;*/
+        case RTK_PHY_CTRL_MIIM_BCAST:
+            phy_826xb_broadcastEnable_set(unit, port, (value == 0)? (DISABLED):(ENABLED));
+            break;
+
+        case RTK_PHY_CTRL_MIIM_BCAST_PHYAD:
+            phy_826xb_broadcastID_set(unit, port, value);
+            break;
+
+      /*  case RTK_PHY_CTRL_SERDES_LOOPBACK_REMOTE:
+            ret = _phy_826xb_serdes_loopback_set(unit, port, value);
+            break;
+
+        case RTK_PHY_CTRL_SERDES_TX_POLARITY:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0xC1, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~RTLBIT_7);
+            phyData |= (value == 0) ? (0) : (RTLBIT_7);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xC1, phyData)) != RT_ERR_OK)
+                return ret;
+            break;
+        case RTK_PHY_CTRL_SERDES_RX_POLARITY:
+            if ((ret = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0xC1, &phyData)) != RT_ERR_OK)
+                return ret;
+            phyData &= (~RTLBIT_6);
+            phyData |= (value == 0) ? (0) : (RTLBIT_6);
+            if ((ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xC1, phyData)) != RT_ERR_OK)
+                return ret;
+            break;*/
+
+        case RTK_PHY_CTRL_RTCT_CABLE_TYPE:
+            _phy_826xb_rtct_cable_set(unit, port, value);
+            break;
+
+     /*   case RTK_PHY_CTRL_SERDES_EYE_PARAM_TYPE:
+            rtl826xb_info[unit]->eyeParamTarget[port] = value;
+            ret = RT_ERR_OK;
+            break;
+
+        case RTK_PHY_CTRL_PTP_REFTIME_TOD_DELAY:
+            if (value > 0xFFFF)
+                return RT_ERR_OUT_OF_RANGE;
+            if ((ret = _phy_826xb_topReg_write(unit, port, 42, 16, 15, 0, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_DURATION_THRESHOLD:
+            if (value > 0x3FF)
+                return RT_ERR_OUT_OF_RANGE;
+            if ((ret = _phy_826xb_topReg_write(unit, port, 42, 17, 9, 0, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_PORT_ROLE:
+            switch (value)
+            {
+                case RTK_PHY_CTRL_PTP_PORT_ROLE_NONE:
+                    phyData = 0x0;
+                    break;
+                case RTK_PHY_CTRL_PTP_PORT_ROLE_BC_OC:
+                    phyData = 0x1;
+                    break;
+                case RTK_PHY_CTRL_PTP_PORT_ROLE_E2E_TC:
+                    phyData = 0x2;
+                    break;
+                case RTK_PHY_CTRL_PTP_PORT_ROLE_P2P_TC:
+                    phyData = 0x3;
+                    break;
+                default:
+                    return RT_ERR_INPUT;
+            }
+            if ((ret = _phy_826xb_topReg_write(unit, port, 50, 16, 3, 2, phyData)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_TX_IMBAL:
+            if (value > 0xFFF)
+                return RT_ERR_OUT_OF_RANGE;
+            if ((ret = _phy_826xb_topReg_write(unit, port, 50, 19, 11, 0, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_RX_IMBAL:
+            if (value > 0xFFF)
+                return RT_ERR_OUT_OF_RANGE;
+            if ((ret = _phy_826xb_topReg_write(unit, port, 50, 20, 11, 0, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_CLOCK_SRC:
+            if ((ret = _phy_826xb_topReg_write(unit, port, 47, 19, 0, 0, (value == RTK_PHY_CTRL_PTP_CLOCK_SRC_INT) ? 0 : 1)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP:
+            if ((ret = phy_826xb_ptp_portPtpEnable_set(unit, port, (value == 0) ? DISABLED : ENABLED)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_PLL_POW_SRC:
+            if ((ret = phy_826xb_ptp_pll_pow_src_set(unit, port, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_PLL_CLK:
+            if ((ret = phy_826xb_ptp_pll_clk_set(unit, port, value)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_PTP_PLL:
+            if ((ret = _phy_826xb_topReg_write(unit, port, 57, 20, 4, 4, (value == 0) ? 0x0 : 0x1)) != RT_ERR_OK)
+                return ret;
+            break;
+
+        case RTK_PHY_CTRL_MACSEC_BYPASS:
+            if ((ret = phy_826xb_macsec_bypass_set(unit, port, (value == 0) ? DISABLED : ENABLED)) != RT_ERR_OK)
+                return ret;
+            break;*/
+
+        default:
+            return RT_ERR_PORT_NOT_SUPPORTED;
+    }
+
+    return SW_OK;
+}
+
+a_int32_t
+_phy_826xb_serdes_mode_init(a_uint32_t unit, a_uint32_t port)
+{
+    
+    a_uint16_t  phyData = 0;
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x105);
+        
+
+    if(phyData & 0x1)
+    {
+        rtl826xb_info[unit]->sdsModeCfg[port] = RTK_PHY_CTRL_SERDES_MODE_UNKNOWN;
+    }
+    else
+    {
+        rtl826xb_info[unit]->sdsModeCfg[port] = RTK_PHY_CTRL_SERDES_MODE_USXGMII;
+    }
+
+    return RT_ERR_OK;
+}
+
+
+a_int32_t
+_phy_826xb_interrupt_init(a_uint32_t unit, a_uint32_t port)
+{
+   
+    a_uint16_t  phyData = 0;
+
+    /* Disable all IMR*/
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE1, 0);
+      
+    /* Disable all SDS IMR*/
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE3, 0);
+      
+
+    /* Set SDS interrupt source to INT_PHY0 */
+   phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE4, 0x1);
+       
+
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE0, 0x2F);
+     
+
+    /* rlfd_en */
+    phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_RAPID_LINK_FAULT_DETECT, 1);
+  
+
+    /* rlfd_fr_en */
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA448);
+      
+    phyData |= (RTLBIT_7);
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA448, phyData);
+       
+
+    /* clear status */
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA43A);
+        
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0xE2, 0x3F);
+       
+
+    return SW_OK;
+}
+
+
+a_int32_t
+_phy_826xb_dbgCount_init(a_uint32_t unit, a_uint32_t port)
+{
+    a_int32_t   ret = RT_ERR_OK;
+    a_uint16_t  phyData = 0;
+
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xC800, 0x5A02);
+    
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1EE);
+     
+    phyData |= RTLBIT_1;
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1EE, phyData);
+      
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x230);
+       
+    phyData |= RTLBIT_1;
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x230, phyData);
+     
+
+    phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_COUNTER_CLEAR, 1);
+    return ret;
+}
+
+
+a_int8_t
+_phy_826xb_is_single_port(a_uint32_t unit, a_uint32_t port)
+{
+ 
+    a_uint16_t  phyData;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x103);
+     
+
+    if ((phyData & 0xF) == 0x1)
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+a_int32_t
+_phy_826xb_synce_init(a_uint32_t unit, a_uint32_t port)
+{
+ 
+    a_uint16_t  phyData = 0;
+    a_uint32_t  is_singlePort = _phy_826xb_is_single_port(unit, port);
+
+    if (1 == is_singlePort)
+    {
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1C8);
+           
+        phyData &= (~(RTLBIT_3));
+        phyData |= (RTLBIT_8);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1C8, phyData);
+           
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1C9);
+            
+        phyData &= (~(RTLBIT_4 | RTLBIT_12));
+        phyData |= (RTLBIT_7 | RTLBIT_15);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1C9, phyData);
+           
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1CA);
+          
+        phyData &= (~(RTLBIT_0 | RTLBIT_1 | RTLBIT_2 | RTLBIT_3 | RTLBIT_4 | RTLBIT_8 | RTLBIT_9 | RTLBIT_10 | RTLBIT_11 | RTLBIT_12 | RTLBIT_15));
+        phyData |= (RTLBIT_5 | RTLBIT_13);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1CA, phyData);
+            
+    }
+    else
+    {
+       
+		phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1C9);
+			
+		phyData &= (~(RTLBIT_4 | RTLBIT_12));
+		phyData |= (RTLBIT_7 | RTLBIT_15);
+		phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1C9, phyData);
+			
+		
+		phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1CA);
+			
+		phyData &= (~(RTLBIT_4 | RTLBIT_12));
+		phyData |= (RTLBIT_5 | RTLBIT_13);
+		phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1CA, phyData);
+			
+		
+		
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1C8);
+          
+        phyData &= (~(RTLBIT_3 | RTLBIT_0));
+        phyData |= (RTLBIT_8);
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1C8, phyData);
+           
+
+        phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x1CA);
+            
+        phyData &= (~(RTLBIT_0 | RTLBIT_1 | RTLBIT_2 | RTLBIT_3 | RTLBIT_8 | RTLBIT_9 | RTLBIT_10 | RTLBIT_11 | RTLBIT_15));
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND1, 0x1CA, phyData);
+           
+    }
+    return SW_OK;
+}
+
+
+
+
+a_int32_t
+phy_826xb_init(a_uint32_t unit, a_uint32_t port)
+{
+   
+    a_int32_t  sz = sizeof(phy_rtl826xb_info_t);
+
+    if (rtl826xb_info[unit] == NULL)
+    {
+        if ((rtl826xb_info[unit] = vzalloc(sz)) == NULL)
+        {
+            return RT_ERR_MEM_ALLOC;
+        }
+        memset(rtl826xb_info[unit], 0, sz);
+    }
+
+    _phy_826xb_serdes_mode_init(unit, port);
+    
+
+    _phy_826xb_interrupt_init(unit, port);
+       
+
+    _phy_826xb_dbgCount_init(unit, port);
+      
+
+    _phy_826xb_synce_init(unit, port);
+       
+
+    phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_RTCT_CABLE_TYPE ,RTK_PHY_CTRL_RTCT_CABLE_TYPE_CAT5E);
+        
+
+    return RT_ERR_OK;
+}
+
+
+
+
+static sw_error_t
+rtl826xb_phy_init(a_uint32_t dev_id, a_uint32_t port_bmp)
+{
+	a_uint32_t phy_addr = 0, port_id = 0;
+	sw_error_t rv = SW_OK;
+	
+	
+	for (port_id = 0; port_id < SW_MAX_NR_PORT; port_id ++)
+    {
+		if (port_bmp & (0x1 << port_id))
+		{
+			phy_addr = qca_ssdk_port_to_phy_addr(dev_id, port_id);
+
+			phy_826xb_ctrl_set(dev_id, phy_addr, RTK_PHY_CTRL_MIIM_BCAST_PHYAD, phy_addr);
+			phy_826xb_ctrl_set(dev_id, phy_addr, RTK_PHY_CTRL_MIIM_BCAST, 1);
+			phy_rtl826xb_broadcast_patch(dev_id, phy_addr, 0);
+			phy_826xb_ctrl_set(dev_id, phy_addr, RTK_PHY_CTRL_MIIM_BCAST, 0);
+			phy_826xb_init(dev_id, phy_addr);
+		}
+	}
+	return rv;
+}
+
+
+a_uint16_t phy_826x_linkStatus_get(a_uint32_t unit, a_uint32_t port)
+{
+    a_uint16_t  phyData = 0;
+	a_uint16_t Status;
+
+	phyData = rtl826x_phy_mmd_read(unit, port, PHY_MMD_PMAPMD, 0x1);
+    Status = (phyData & RTLBIT_2) ? PORT_LINKUP : PORT_LINKDOWN;
+    return Status;
+}
+
+
+
+a_int32_t phy_common_c45_speed_set(a_uint32_t unit, a_uint32_t port, fal_port_speed_t speed)
+{
+   
+    a_uint16_t  phyData = 0;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_PMAPMD, 0);
+    
+
+    phyData &= (~(RTLBIT_13 | RTLBIT_6 | RTLBIT_5 | RTLBIT_4 | RTLBIT_3 | RTLBIT_2));
+
+    switch (speed)
+    {
+        case FAL_SPEED_10:
+            break;
+        case FAL_SPEED_100:
+            phyData |= RTLBIT_13;
+            break;
+        case FAL_SPEED_1000:
+            phyData |= RTLBIT_6;
+            break;
+        case FAL_SPEED_10000:
+            phyData |= (RTLBIT_13 | RTLBIT_6);
+            break;
+        case FAL_SPEED_2500:
+            phyData |= (RTLBIT_13 | RTLBIT_6 | RTLBIT_4 | RTLBIT_3);
+            break;
+        case FAL_SPEED_5000:
+            phyData |= (RTLBIT_13 | RTLBIT_6 | RTLBIT_4 | RTLBIT_3 | RTLBIT_2);
+            break;
+        default:
+            return SW_NOT_SUPPORTED;
+    }
+
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_PMAPMD, 0, phyData);
+    return SW_OK;
+}
+
+a_uint32_t
+_phy_826xb_an_restart(a_uint32_t unit, a_uint32_t port)
+{
+    a_uint16_t  phyData = 0;
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 0);
+
+    if (phyData & 0x1000) /*AN is enabled*/
+    {
+        phyData |= 0x0200; /*AN restart*/
+        phy_common_general_reg_mmd_set(unit, port, PHY_MMD_AN, 0, phyData);
+        
+    }
+    return SW_OK;
+}
+
+sw_error_t phy_826xb_duplex_get(a_uint32_t unit, a_uint32_t port, fal_port_duplex_t *duplex)
+{
+   
+    a_uint16_t  phyData = 0;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA434);
+        
+
+    *duplex = (phyData & 0x8) ? PORT_FULL_DUPLEX : PORT_HALF_DUPLEX;
+
+    return SW_OK;
+}
+
+sw_error_t phy_826xb_speed_set(a_uint32_t unit, a_uint32_t port, fal_port_speed_t speed)
+{
+   
+    a_uint16_t  remote_loopback = 0;
+	a_uint16_t  phyData;
+	fal_port_duplex_t old_duplex;
+
+
+    if (FAL_SPEED_100 != speed)
+    {
+        return SW_OUT_OF_RANGE;
+    }
+	
+	phy_826xb_duplex_get(unit, port, &old_duplex);
+	
+	 phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND1, 0x2A1);
+     remote_loopback = (phyData & RTLBIT_10) ? (1) : (0);
+
+  //  phy_826xb_ctrl_get(unit, port, RTK_PHY_CTRL_LOOPBACK_REMOTE, &remote_loopback);
+    phy_common_c45_speed_set(unit, port, speed);
+    _phy_826xb_an_restart(unit, port);
+
+    if (remote_loopback != 0)
+    {
+        phy_826xb_ctrl_set(unit, port, RTK_PHY_CTRL_LOOPBACK_REMOTE, remote_loopback);
+     
+    }
+
+    return SW_OK;
+}
+
+sw_error_t rtl826x_phy_get_status(a_uint32_t dev_id, a_uint32_t phy_id, struct port_phy_status *phy_status)
+{
+	a_uint16_t phyData, spd;
+
+	
+	phy_status->link_status = phy_826x_linkStatus_get(dev_id, phy_id);
+	if(phy_status->link_status != A_TRUE)
+	{
+		return SW_OK;
+	}
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_VEND2, 0xA434);
+	spd = ((phyData & (0x3 << 9)) >> (9 - 2)) | ((phyData & (0x3 << 4)) >> 4);
+	
+		
+	switch (spd)
+    {
+        case 0x0:
+    
+		  phy_status->speed = FAL_SPEED_10;
+          break;
+        case 0x1:
+      
+		  phy_status->speed = FAL_SPEED_100;
+          break;
+        case 0x2:
+     
+		  phy_status->speed = FAL_SPEED_1000;
+          break;
+     
+        case 0x4:
+  
+		  phy_status->speed = FAL_SPEED_10000;
+          break;
+        case 0x5:
+   
+		  phy_status->speed = FAL_SPEED_2500;
+          break;
+        case 0x6:
+			phy_status->speed = FAL_SPEED_5000;
+          break;
+        default: 
+			phy_status->speed = FAL_SPEED_10;
+          break;
+    }
+	
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_VEND2, 0xA434);
+        
+
+    phy_status->duplex = (phyData & 0x8) ? FAL_FULL_DUPLEX : FAL_HALF_DUPLEX;
+	
+	phy_status->rx_flowctrl = A_FALSE;
+	
+	phy_status->tx_flowctrl = A_FALSE;
+
+	return SW_OK;
+}
+
+
+sw_error_t phy_common_c45_reset_set(a_uint32_t unit, a_uint32_t port)
+{ 
+    a_uint16_t  phyData = 0;
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_PMAPMD, 0);
+    phyData |= RTLBIT_15;
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_PMAPMD, 0, phyData);
+    return SW_OK;
+}
+
+sw_error_t
+phy_common_c45_autoNegoEnable_set(a_uint32_t unit, a_uint32_t port)
+{
+    sw_error_t   ret;
+    a_uint16_t  phyData = 0;
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 0);
+
+    phyData |= 0x1000;
+	
+
+    ret = phy_common_general_reg_mmd_set(unit, port, PHY_MMD_AN, 0, phyData);
+    return ret;
+}
+
+sw_error_t phy_826xb_autoNegoEnable_set(a_uint32_t unit, a_uint32_t port)
+{
+	return phy_common_c45_autoNegoEnable_set(unit, port);
+}
+
+
+sw_error_t phy_826xb_restart_autoneg(a_uint32_t dev_id, a_uint32_t port)
+{
+	
+	a_uint16_t ctl;
+	
+	ctl = phy_common_general_reg_mmd_get(dev_id, port, PHY_MMD_AN, 0x0);
+
+	if (ctl < 0)
+		return ctl;
+
+	ctl |= (RTLBIT_12 | RTLBIT_9);
+
+	phy_common_general_reg_mmd_set(dev_id, port, PHY_MMD_AN, 0x0, ctl);
+	return SW_OK;
+
+}
+
+a_bool_t
+phy_common_c45_autoNegoEnable_get(a_uint32_t unit, a_uint32_t port)
+{
+   
+    a_uint16_t phyData = 0;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 0);
+	
+	if (phyData & RTLBIT_12) {
+		return A_TRUE;
+	}
+
+	return A_FALSE;
+}
+
+
+sw_error_t
+phy_826xb_autoNegoAbility_set(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t autoneg)
+{
+   
+    a_uint16_t  phyData = 0;
+    
+    if ((autoneg & 1 << 0) || (autoneg & 1 << 1))
+    {
+        return RT_ERR_INPUT;
+    }
+
+ 
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_AN, 16);
+
+    phyData &= (~(0x0020 | 0x0040 | 0x0080 | 0x0100 | 0x0400 | 0x0800));
+    phyData |= ((autoneg & 1 << 2)) ? (0x0080) : (0);
+    phyData |= ((autoneg & 1 << 3)) ? (0x0100) : (0);
+    phyData |= ((autoneg & 1 << 9)) ? (0x0400) : (0);
+    phyData |= ((autoneg & 1 << 10)) ? (0x0800) : (0);
+
+    phy_common_general_reg_mmd_set(dev_id, phy_id, PHY_MMD_AN, 16, phyData);
+	
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_AN, 32);
+
+    phyData &= (~(0x0080 | 0x0100 | 0x1000));
+    phyData |= (autoneg & 1 << 6) ? (0x0080) : (0);
+    phyData |= (autoneg & 1 << 7) ? (0x0100) : (0);
+    phyData |= (autoneg & 1 << 8) ? (0x1000) : (0);
+
+    phy_common_general_reg_mmd_set(dev_id, phy_id, PHY_MMD_AN, 32, phyData);
+     
+	
+	phyData = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_VEND2, 0xA412);
+
+
+    phyData &= (~(0x0100 | 0x0200));
+    phyData |= (autoneg & 1 << 4) ? (0x0100) : (0);
+    phyData |= (autoneg & 1 << 5) ? (0x0200) : (0);
+
+    phy_common_general_reg_mmd_set(dev_id, phy_id, PHY_MMD_VEND2, 0xA412, phyData);
+        
+
+    _phy_826xb_an_restart(dev_id, phy_id);
+    return SW_OK;
+}
+
+sw_error_t
+phy_common_c45_autoNegoAbility_get(a_uint32_t unit, a_uint32_t port, a_uint32_t *autoneg)
+{
+    sw_error_t   ret = SW_OK;
+    a_uint16_t  phyData = 0;
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 16);
+
+    *autoneg  |= (phyData & 0x0020) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0040) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0080) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0100) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0400) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0800) ? (1) : (0);
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_AN, 32);
+
+    *autoneg  |= (phyData & 0x0080) ? (1) : (0);
+    *autoneg  |= (phyData & 0x0100) ? (1) : (0);
+    *autoneg  |= (phyData & 0x1000) ? (1) : (0);
+
+    return ret;
+}
+
+
+
+sw_error_t
+phy_826x_autoNegoAbility_get(a_uint32_t unit, a_uint32_t port, a_uint32_t *autoneg)
+{
+    
+    a_uint16_t  phyData = 0;
+  
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA412);
+
+    *autoneg  = (phyData & 0x0100) ? (1) : (0);
+    *autoneg  = (phyData & 0x0200) ? (1) : (0);
+
+    phy_common_c45_autoNegoAbility_get(unit, port, autoneg);
+
+    
+
+    return SW_OK;
+}
+
+a_bool_t
+phy_826xb_linkStatus_get(a_uint32_t unit, a_uint32_t port)
+{
+    a_uint16_t  phyData = 0;
+	
+	a_bool_t rv = A_TRUE;
+	phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_PMAPMD, 0x1);
+
+    rv = (phyData & 0x0004) ? PORT_LINKUP : PORT_LINKDOWN;
+    return rv;
+}
+
+
+sw_error_t phy_826xb_phy_id_get(a_uint32_t dev_id, a_uint32_t phy_id, a_uint32_t *phy_data)
+{
+	a_uint16_t org_id, rev_id;
+	org_id = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_PMAPMD, 0x2);
+	rev_id = phy_common_general_reg_mmd_get(dev_id, phy_id, PHY_MMD_PMAPMD, 0x3);
+	
+	*phy_data = ((org_id & 0xffff) << 16) | (rev_id & 0xffff);
+
+	return SW_OK;
+}
+
+
+sw_error_t
+phy_826xb_interface_get_mode_status(a_uint32_t dev_id, a_uint32_t phy_id,
+		fal_port_interface_mode_t *interface_mode_status)
+{
+	*interface_mode_status = PORT_USXGMII;
+	return SW_OK;
+}
+
+sw_error_t phy_826xb_poweron(a_uint32_t dev_id, a_uint32_t phy_id)
+{
+
+
+	return SW_OK;
+}
+
+sw_error_t phy_826xb_poweroff(a_uint32_t dev_id, a_uint32_t phy_id)
+{
+
+	return SW_OK;
+}
+
+sw_error_t phy_826xb_duplex_set(a_uint32_t unit, a_uint32_t port, fal_port_duplex_t duplex)
+{
+    
+    a_uint16_t  phyData = 0;
+
+    phyData = phy_common_general_reg_mmd_get(unit, port, PHY_MMD_VEND2, 0xA400);
+
+    phyData = (duplex == FAL_FULL_DUPLEX) ? (phyData | RTLBIT_8) : (phyData & ~RTLBIT_8);
+
+    phy_common_general_reg_mmd_set(unit, port, PHY_MMD_VEND2, 0xA400, phyData);
+    return SW_OK;
+}
+
+
+
+static sw_error_t rtl826xb_phy_api_ops_init(void)
+{
+	sw_error_t  ret = SW_OK;
+	hsl_phy_ops_t *rtl826xb_phy_api_ops = NULL;
+
+	rtl826xb_phy_api_ops = kzalloc(sizeof(hsl_phy_ops_t), GFP_KERNEL);
+	if (rtl826xb_phy_api_ops == NULL) {
+		SSDK_ERROR("rtl phy ops kzalloc failed!\n");
+		return -1;
+	}
+
+	phy_api_ops_init(RTL_PHY_CHIP);
+	
+	rtl826xb_phy_api_ops->phy_reg_write = rtl826x_phy_reg_write;
+	rtl826xb_phy_api_ops->phy_reg_read = rtl826x_phy_reg_read;
+	rtl826xb_phy_api_ops->phy_mmd_read=rtl826x_phy_mmd_read;
+    rtl826xb_phy_api_ops->phy_mmd_write=rtl826x_phy_mmd_write;
+	
+	rtl826xb_phy_api_ops->phy_get_status=rtl826x_phy_get_status;	
+	rtl826xb_phy_api_ops->phy_speed_get=phy_common_c45_speed_get;	
+	rtl826xb_phy_api_ops->phy_speed_set=phy_826xb_speed_set;	
+	rtl826xb_phy_api_ops->phy_duplex_get=phy_826xb_duplex_get;
+	rtl826xb_phy_api_ops->phy_duplex_set=phy_826xb_duplex_set;	
+	rtl826xb_phy_api_ops->phy_reset=phy_common_c45_reset_set;
+	
+	rtl826xb_phy_api_ops->phy_autoneg_enable_set=phy_826xb_autoNegoEnable_set;	
+	rtl826xb_phy_api_ops->phy_restart_autoneg=phy_826xb_restart_autoneg;	
+	rtl826xb_phy_api_ops->phy_autoneg_status_get=phy_common_c45_autoNegoEnable_get;	
+	rtl826xb_phy_api_ops->phy_autoneg_adv_set=phy_826xb_autoNegoAbility_set;	
+	rtl826xb_phy_api_ops->phy_autoneg_adv_get=phy_826x_autoNegoAbility_get;
+	
+	rtl826xb_phy_api_ops->phy_link_status_get=phy_826xb_linkStatus_get;
+	rtl826xb_phy_api_ops->phy_power_on=phy_826xb_poweron;
+	rtl826xb_phy_api_ops->phy_power_off=phy_826xb_poweroff;
+	rtl826xb_phy_api_ops->phy_id_get=phy_826xb_phy_id_get;
+	rtl826xb_phy_api_ops->phy_interface_mode_status_get=phy_826xb_interface_get_mode_status;
+	
+	ret = hsl_phy_api_ops_register(RTL_PHY_CHIP, rtl826xb_phy_api_ops);
+
+	if (ret == SW_OK) {
+		SSDK_INFO("qca probe rtl826xb phy driver succeeded!\n");
+	} else {
+		SSDK_ERROR("qca probe rtl826xb phy driver failed! (code: %d)\n", ret);
+	}
+
+	return ret;
+	
+
+}
+
+
+
+/******************************************************************************
+*
+* rtl_phy_init -
+*
+*/
+int rtl_phy_init(a_uint32_t dev_id, a_uint32_t port_bmp)
+{
+	a_int32_t ret = 0;
+	a_int32_t port_id = 0;
+
+	if(phy_ops_flag == 0) {
+		rtl826xb_phy_lock_init();
+		rtl826xb_phy_api_ops_init();
+		phy_ops_flag = 1;
+	}
+	rtl826xb_phy_init(dev_id, port_bmp);
+	if(phy_dev_drv_init_flag == 0)
+	{
+		for (port_id = 0; port_id < SW_MAX_NR_PORT; port_id ++)
+		{
+			if (port_bmp & (0x1 << port_id)) {
+				rtl_phydev_init(dev_id, port_id);
+			}
+		}
+		ret = rtl_phy_driver_register();
+		phy_dev_drv_init_flag = 1;
+	}
+
+
+	return ret;
+}
diff --git a/src/init/ssdk_init.c b/src/init/ssdk_init.c
index 4b4ecfd1..aeb332fe 100755
--- a/src/init/ssdk_init.c
+++ b/src/init/ssdk_init.c
@@ -511,6 +511,14 @@ qca_switch_init(a_uint32_t dev_id)
 			switch (chip_type) {
 				case CHIP_SHIVA:
 					return SW_OK;
+				case CHIP_APPE:
+					SSDK_DEBUG("set APPE port 2 flowctrl force mode & flowctrl enable\n");
+					if(2 == i)
+					{
+						fal_port_flowctrl_forcemode_set(dev_id, i, A_TRUE);
+						fal_port_flowctrl_set(dev_id, i, A_TRUE);
+					}
+					break;
 				case CHIP_DESS:
 #ifdef DESS
 #ifdef IN_PORTCONTROL
@@ -620,6 +628,8 @@ qca_switch_init(a_uint32_t dev_id)
 					if (cpu_bmp & BIT(i)) {
 #if defined(IN_PORTCONTROL)
 						fal_port_flowctrl_forcemode_set(dev_id, i, A_TRUE);
+//						fal_port_flow_ctrl_thres_set(dev_id, i,
+//								MHT_PORT0_XON_THRES, MHT_PORT0_XOFF_THRES);
 						fal_header_type_set(dev_id,
 								A_TRUE, MHT_HEADER_TYPE_VAL);
 						fal_port_rxhdr_mode_set(dev_id,
@@ -1413,6 +1423,27 @@ qca_phy_mib_work_stop(struct qca_phy_priv *priv)
 	cancel_delayed_work_sync(&priv->mib_dwork);
 }
 
+void
+qca_phy_mib_work_pause(struct qca_phy_priv *priv)
+{
+	if(!priv)
+		return;
+	cancel_delayed_work_sync(&priv->mib_dwork);
+}
+
+int
+qca_phy_mib_work_resume(struct qca_phy_priv *priv)
+{
+#ifndef SSDK_MIB_CHANGE_WQ
+	schedule_delayed_work(&priv->mib_dwork,
+			               msecs_to_jiffies(QCA_PHY_MIB_WORK_DELAY));
+#else
+	queue_delayed_work_on(0, system_long_wq, &priv->mib_dwork,
+					msecs_to_jiffies(QCA_PHY_MIB_WORK_DELAY));
+#endif
+	return 0;
+}
+
 #define SSDK_QM_CHANGE_WQ
 
 static void
-- 
2.34.1

