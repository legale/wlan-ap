From 535578009d2fdcf368b6595695e4d4ea5a8afafa Mon Sep 17 00:00:00 2001
From: Isaev Ruslan <legale.legale@gmail.com>
Date: Sun, 17 Mar 2024 01:27:21 +0300
Subject: [PATCH 3/4] gpio-button-hotplug: update package

Signed-off-by: Isaev Ruslan <legale.legale@gmail.com>
---
 package/kernel/gpio-button-hotplug/Makefile   |   1 +
 .../src/gpio-button-hotplug.c                 | 258 +++++++-----------
 2 files changed, 95 insertions(+), 164 deletions(-)

diff --git a/package/kernel/gpio-button-hotplug/Makefile b/package/kernel/gpio-button-hotplug/Makefile
index 7ca6195a03..18a6c2a149 100644
--- a/package/kernel/gpio-button-hotplug/Makefile
+++ b/package/kernel/gpio-button-hotplug/Makefile
@@ -18,6 +18,7 @@ define KernelPackage/gpio-button-hotplug
   SUBMENU:=Other modules
   TITLE:=Simple GPIO Button Hotplug driver
   FILES:=$(PKG_BUILD_DIR)/gpio-button-hotplug.ko
+  $(info debugkmod PKG_BUILD_DIR is: $(PKG_BUILD_DIR))
   AUTOLOAD:=$(call AutoLoad,30,gpio-button-hotplug,1)
   KCONFIG:=
 endef
diff --git a/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c b/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
index 9575c6245b..f94b29833c 100644
--- a/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
+++ b/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
@@ -26,15 +26,28 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/of_gpio.h>
-#include <linux/of_irq.h>
 #include <linux/gpio_keys.h>
-#include <linux/gpio/consumer.h>
+
+#define DRV_NAME	"gpio-keys"
 
 #define BH_SKB_SIZE	2048
 
-#define DRV_NAME	"gpio-keys"
 #define PFX	DRV_NAME ": "
 
+#undef BH_DEBUG
+
+#ifdef BH_DEBUG
+#define BH_DBG(fmt, args...) printk(KERN_DEBUG "%s: " fmt, DRV_NAME, ##args )
+#else
+#define BH_DBG(fmt, args...) do {} while (0)
+#endif
+
+#define BH_ERR(fmt, args...) printk(KERN_ERR "%s: " fmt, DRV_NAME, ##args )
+
+struct bh_priv {
+	unsigned long		seen;
+};
+
 struct bh_event {
 	const char		*name;
 	unsigned int		type;
@@ -52,16 +65,12 @@ struct bh_map {
 
 struct gpio_keys_button_data {
 	struct delayed_work work;
-	unsigned long seen;
-	int map_entry;
+	struct bh_priv bh;
 	int last_state;
 	int count;
 	int threshold;
 	int can_sleep;
-	int irq;
-	unsigned int software_debounce;
-	struct gpio_desc *gpiod;
-	const struct gpio_keys_button *b;
+	struct gpio_keys_button *b;
 };
 
 extern u64 uevent_next_seqnum(void);
@@ -91,12 +100,9 @@ static struct bh_map button_map[] = {
 	BH_MAP(KEY_LIGHTS_TOGGLE,	"lights_toggle"),
 	BH_MAP(KEY_PHONE,		"phone"),
 	BH_MAP(KEY_POWER,		"power"),
-	BH_MAP(KEY_POWER2,		"reboot"),
 	BH_MAP(KEY_RESTART,		"reset"),
 	BH_MAP(KEY_RFKILL,		"rfkill"),
 	BH_MAP(KEY_VIDEO,		"video"),
-	BH_MAP(KEY_VOLUMEDOWN,		"volume_down"),
-	BH_MAP(KEY_VOLUMEUP,		"volume_up"),
 	BH_MAP(KEY_WIMAX,		"wwan"),
 	BH_MAP(KEY_WLAN,		"wlan"),
 	BH_MAP(KEY_WPS_BUTTON,		"wps"),
@@ -127,7 +133,7 @@ int bh_event_add_var(struct bh_event *event, int argv, const char *format, ...)
 	s = skb_put(event->skb, len + 1);
 	strcpy(s, buf);
 
-	pr_debug(PFX "added variable '%s'\n", s);
+	BH_DBG("added variable '%s'\n", s);
 
 	return 0;
 }
@@ -194,7 +200,7 @@ static void button_hotplug_work(struct work_struct *work)
 
  out_free_skb:
 	if (ret) {
-		pr_err(PFX "work error %d\n", ret);
+		BH_ERR("work error %d\n", ret);
 		kfree_skb(event->skb);
 	}
  out_free_event:
@@ -206,8 +212,8 @@ static int button_hotplug_create_event(const char *name, unsigned int type,
 {
 	struct bh_event *event;
 
-	pr_debug(PFX "create event, name=%s, seen=%lu, pressed=%d\n",
-		 name, seen, pressed);
+	BH_DBG("create event, name=%s, seen=%lu, pressed=%d\n",
+		name, seen, pressed);
 
 	event = kzalloc(sizeof(*event), GFP_KERNEL);
 	if (!event)
@@ -237,6 +243,36 @@ static int button_get_index(unsigned int code)
 	return -1;
 }
 
+static void button_hotplug_event(struct gpio_keys_button_data *data,
+			   unsigned int type, int value)
+{
+	struct bh_priv *priv = &data->bh;
+	unsigned long seen = jiffies;
+	int btn;
+
+	BH_DBG("event type=%u, code=%u, value=%d\n", type, data->b->code, value);
+
+	if ((type != EV_KEY) && (type != EV_SW))
+		return;
+
+	btn = button_get_index(data->b->code);
+	if (btn < 0)
+		return;
+
+	button_hotplug_create_event(button_map[btn].name, type,
+			(seen - priv->seen) / HZ, value);
+	priv->seen = seen;
+}
+
+struct gpio_keys_button_dev {
+	int polled;
+	struct delayed_work work;
+
+	struct device *dev;
+	struct gpio_keys_platform_data *pdata;
+	struct gpio_keys_button_data data[0];
+};
+
 static int gpio_button_get_value(struct gpio_keys_button_data *bdata)
 {
 	int val;
@@ -249,61 +285,27 @@ static int gpio_button_get_value(struct gpio_keys_button_data *bdata)
 	return val ^ bdata->b->active_low;
 }
 
-static void gpio_keys_handle_button(struct gpio_keys_button_data *bdata)
+static void gpio_keys_polled_check_state(struct gpio_keys_button_data *bdata)
 {
-	unsigned int type = bdata->b->type ?: EV_KEY;
 	int state = gpio_button_get_value(bdata);
-	unsigned long seen = jiffies;
 
-	pr_debug(PFX "event type=%u, code=%u, pressed=%d\n",
-		 type, bdata->b->code, state);
-
-	/* is this the initialization state? */
-	if (bdata->last_state == -1) {
-		/*
-		 * Don't advertise unpressed buttons on initialization.
-		 * Just save their state and continue otherwise this
-		 * can cause OpenWrt to enter failsafe.
-		 */
-		if (type == EV_KEY && state == 0)
-			goto set_state;
-		/*
-		 * But we are very interested in pressed buttons and
-		 * initial switch state. These will be reported to
-		 * userland.
-		 */
-	} else if (bdata->last_state == state) {
-		/* reset asserted counter (only relevant for polled keys) */
-		bdata->count = 0;
-		return;
-	}
+	if (state != bdata->last_state) {
+		unsigned int type = bdata->b->type ?: EV_KEY;
 
-	if (bdata->count < bdata->threshold) {
-		bdata->count++;
-		return;
-	}
+		if (bdata->count < bdata->threshold) {
+			bdata->count++;
+			return;
+		}
 
-	if (bdata->seen == 0)
-		bdata->seen = seen;
+		if ((bdata->last_state != -1) || (type == EV_SW))
+			button_hotplug_event(bdata, type, state);
 
-	button_hotplug_create_event(button_map[bdata->map_entry].name, type,
-				    (seen - bdata->seen) / HZ, state);
-	bdata->seen = seen;
+		bdata->last_state = state;
+	}
 
-set_state:
-	bdata->last_state = state;
 	bdata->count = 0;
 }
 
-struct gpio_keys_button_dev {
-	int polled;
-	struct delayed_work work;
-
-	struct device *dev;
-	struct gpio_keys_platform_data *pdata;
-	struct gpio_keys_button_data data[0];
-};
-
 static void gpio_keys_polled_queue_work(struct gpio_keys_button_dev *bdev)
 {
 	struct gpio_keys_platform_data *pdata = bdev->pdata;
@@ -322,9 +324,7 @@ static void gpio_keys_polled_poll(struct work_struct *work)
 
 	for (i = 0; i < bdev->pdata->nbuttons; i++) {
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
-
-		if (bdata->gpiod)
-			gpio_keys_handle_button(bdata);
+		gpio_keys_polled_check_state(bdata);
 	}
 	gpio_keys_polled_queue_work(bdev);
 }
@@ -339,21 +339,11 @@ static void gpio_keys_polled_close(struct gpio_keys_button_dev *bdev)
 		pdata->disable(bdev->dev);
 }
 
-static void gpio_keys_irq_work_func(struct work_struct *work)
-{
-	struct gpio_keys_button_data *bdata = container_of(work,
-		struct gpio_keys_button_data, work.work);
-
-	gpio_keys_handle_button(bdata);
-}
-
 static irqreturn_t button_handle_irq(int irq, void *_bdata)
 {
-	struct gpio_keys_button_data *bdata =
-		(struct gpio_keys_button_data *) _bdata;
+	struct gpio_keys_button_data *bdata = (struct gpio_keys_button_data *) _bdata;
 
-	mod_delayed_work(system_wq, &bdata->work,
-			 msecs_to_jiffies(bdata->software_debounce));
+	button_hotplug_event(bdata, bdata->b->type ?: EV_KEY, gpio_button_get_value(bdata));
 
 	return IRQ_HANDLED;
 }
@@ -399,9 +389,7 @@ gpio_keys_get_devtree_pdata(struct device *dev)
 			continue;
 		}
 
-		button = (struct gpio_keys_button *)(&pdata->buttons[i++]);
-
-		button->irq = irq_of_parse_and_map(pp, 0);
+		button = &pdata->buttons[i++];
 
 		button->gpio = of_get_gpio_flags(pp, 0, &flags);
 		if (button->gpio < 0) {
@@ -414,7 +402,7 @@ gpio_keys_get_devtree_pdata(struct device *dev)
 				return ERR_PTR(error);
 			}
 		} else {
-			button->active_low = !!(flags & OF_GPIO_ACTIVE_LOW);
+			button->active_low = flags & OF_GPIO_ACTIVE_LOW;
 		}
 
 		if (of_property_read_u32(pp, "linux,code", &button->code)) {
@@ -517,23 +505,10 @@ static int gpio_keys_button_probe(struct platform_device *pdev,
 		unsigned int gpio = button->gpio;
 
 		if (button->wakeup) {
-			dev_err(dev, "does not support wakeup\n");
+			dev_err(dev, DRV_NAME "does not support wakeup\n");
 			return -EINVAL;
 		}
 
-		bdata->map_entry = button_get_index(button->code);
-		if (bdata->map_entry < 0) {
-			dev_warn(dev, "does not support key code:%u\n",
-				button->code);
-			continue;
-		}
-
-		if (!(button->type == 0 || button->type == EV_KEY ||
-		      button->type == EV_SW)) {
-			dev_warn(dev, "only supports buttons or switches\n");
-			continue;
-		}
-
 		error = devm_gpio_request(dev, gpio,
 				     button->desc ? button->desc : DRV_NAME);
 		if (error) {
@@ -541,9 +516,6 @@ static int gpio_keys_button_probe(struct platform_device *pdev,
 				gpio, error);
 			return error;
 		}
-		bdata->gpiod = gpio_to_desc(gpio);
-		if (!bdata->gpiod)
-			return -EINVAL;
 
 		error = gpio_direction_input(gpio);
 		if (error) {
@@ -554,27 +526,13 @@ static int gpio_keys_button_probe(struct platform_device *pdev,
 		}
 
 		bdata->can_sleep = gpio_cansleep(gpio);
-		bdata->last_state = -1; /* Unknown state on boot */
+		bdata->last_state = -1;
 
-		if (bdev->polled) {
+		if (bdev->polled)
 			bdata->threshold = DIV_ROUND_UP(button->debounce_interval,
-							pdata->poll_interval);
-		} else {
-			/* bdata->threshold = 0; already initialized */
-
-			if (button->debounce_interval) {
-				error = gpiod_set_debounce(bdata->gpiod,
-					button->debounce_interval * 1000);
-				/*
-				 * use timer if gpiolib doesn't provide
-				 * debounce.
-				 */
-				if (error < 0) {
-					bdata->software_debounce =
-						button->debounce_interval;
-				}
-			}
-		}
+						pdata->poll_interval);
+		else
+			bdata->threshold = 1;
 
 		bdata->b = &pdata->buttons[i];
 	}
@@ -602,45 +560,26 @@ static int gpio_keys_probe(struct platform_device *pdev)
 
 	pdata = bdev->pdata;
 	for (i = 0; i < pdata->nbuttons; i++) {
-		const struct gpio_keys_button *button = &pdata->buttons[i];
+		struct gpio_keys_button *button = &pdata->buttons[i];
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
-		unsigned long irqflags = IRQF_ONESHOT;
-
-		INIT_DELAYED_WORK(&bdata->work, gpio_keys_irq_work_func);
 
-		if (!bdata->gpiod)
+		if (!button->irq)
+			button->irq = gpio_to_irq(button->gpio);
+		if (button->irq < 0) {
+			dev_err(&pdev->dev, "failed to get irq for gpio:%d\n", button->gpio);
 			continue;
-
-		if (!button->irq) {
-			bdata->irq = gpio_to_irq(button->gpio);
-
-			if (bdata->irq < 0) {
-				dev_err(&pdev->dev, "failed to get irq for gpio:%d\n",
-					button->gpio);
-				continue;
-			}
-
-			irqflags |= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
-		} else {
-			bdata->irq = button->irq;
 		}
 
-		schedule_delayed_work(&bdata->work,
-				      msecs_to_jiffies(bdata->software_debounce));
+		ret = devm_request_threaded_irq(&pdev->dev, button->irq, NULL, button_handle_irq,
+						IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+						dev_name(&pdev->dev), bdata);
+		if (ret < 0)
+			dev_err(&pdev->dev, "failed to request irq:%d for gpio:%d\n", button->irq, button->gpio);
+		else
+			dev_dbg(&pdev->dev, "gpio:%d has irq:%d\n", button->gpio, button->irq);
 
-		ret = devm_request_threaded_irq(&pdev->dev,
-			bdata->irq, NULL, button_handle_irq,
-			irqflags, dev_name(&pdev->dev), bdata);
-
-		if (ret < 0) {
-			bdata->irq = 0;
-			dev_err(&pdev->dev, "failed to request irq:%d for gpio:%d\n",
-				bdata->irq, button->gpio);
-			continue;
-		} else {
-			dev_dbg(&pdev->dev, "gpio:%d has irq:%d\n",
-				button->gpio, bdata->irq);
-		}
+		if (bdata->b->type == EV_SW)
+			button_hotplug_event(bdata, EV_SW, gpio_button_get_value(bdata));
 	}
 
 	return 0;
@@ -651,6 +590,7 @@ static int gpio_keys_polled_probe(struct platform_device *pdev)
 	struct gpio_keys_platform_data *pdata;
 	struct gpio_keys_button_dev *bdev;
 	int ret;
+	int i;
 
 	ret = gpio_keys_button_probe(pdev, &bdev, 1);
 
@@ -664,24 +604,14 @@ static int gpio_keys_polled_probe(struct platform_device *pdev)
 	if (pdata->enable)
 		pdata->enable(bdev->dev);
 
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_keys_polled_check_state(&bdev->data[i]);
+
 	gpio_keys_polled_queue_work(bdev);
 
 	return ret;
 }
 
-static void gpio_keys_irq_close(struct gpio_keys_button_dev *bdev)
-{
-	struct gpio_keys_platform_data *pdata = bdev->pdata;
-	size_t i;
-
-	for (i = 0; i < pdata->nbuttons; i++) {
-		struct gpio_keys_button_data *bdata = &bdev->data[i];
-
-		disable_irq(bdata->irq);
-		cancel_delayed_work_sync(&bdata->work);
-	}
-}
-
 static int gpio_keys_remove(struct platform_device *pdev)
 {
 	struct gpio_keys_button_dev *bdev = platform_get_drvdata(pdev);
@@ -690,8 +620,6 @@ static int gpio_keys_remove(struct platform_device *pdev)
 
 	if (bdev->polled)
 		gpio_keys_polled_close(bdev);
-	else
-		gpio_keys_irq_close(bdev);
 
 	return 0;
 }
@@ -745,3 +673,5 @@ MODULE_AUTHOR("Felix Fietkau <nbd@nbd.name>");
 MODULE_DESCRIPTION("Polled GPIO Buttons hotplug driver");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRV_NAME);
+
+
-- 
2.42.0

